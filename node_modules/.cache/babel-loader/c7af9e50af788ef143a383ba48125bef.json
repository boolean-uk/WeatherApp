{"ast":null,"code":"import _defineProperty from \"/Users/mu.../Documents/Boolean/React/WeatherApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/mu.../Documents/Boolean/React/WeatherApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/mu.../Documents/Boolean/React/WeatherApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/mu.../Documents/Boolean/React/WeatherApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mu.../Documents/Boolean/React/WeatherApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */\nimport { tokenizeArgString } from './tokenize-arg-string.js';\nimport { DefaultValuesForTypeKey } from './yargs-parser-types.js';\nimport { camelCase, decamelize, looksLikeNumber } from './string-utils.js';\nvar mixin;\nexport var YargsParser = /*#__PURE__*/function () {\n  function YargsParser(_mixin) {\n    _classCallCheck(this, YargsParser);\n\n    mixin = _mixin;\n  }\n\n  _createClass(YargsParser, [{\n    key: \"parse\",\n    value: function parse(argsInput, options) {\n      var opts = Object.assign({\n        alias: undefined,\n        array: undefined,\n        boolean: undefined,\n        config: undefined,\n        configObjects: undefined,\n        configuration: undefined,\n        coerce: undefined,\n        count: undefined,\n        default: undefined,\n        envPrefix: undefined,\n        narg: undefined,\n        normalize: undefined,\n        string: undefined,\n        number: undefined,\n        __: undefined,\n        key: undefined\n      }, options); // allow a string argument to be passed in rather\n      // than an argv array.\n\n      var args = tokenizeArgString(argsInput); // tokenizeArgString adds extra quotes to args if argsInput is a string\n      // only strip those extra quotes in processValue if argsInput is a string\n\n      var inputIsString = typeof argsInput === 'string'; // aliases might have transitive relationships, normalize this.\n\n      var aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n      var configuration = Object.assign({\n        'boolean-negation': true,\n        'camel-case-expansion': true,\n        'combine-arrays': false,\n        'dot-notation': true,\n        'duplicate-arguments-array': true,\n        'flatten-duplicate-arrays': true,\n        'greedy-arrays': true,\n        'halt-at-non-option': false,\n        'nargs-eats-options': false,\n        'negation-prefix': 'no-',\n        'parse-numbers': true,\n        'parse-positional-numbers': true,\n        'populate--': false,\n        'set-placeholder-key': false,\n        'short-option-groups': true,\n        'strip-aliased': false,\n        'strip-dashed': false,\n        'unknown-options-as-args': false\n      }, opts.configuration);\n      var defaults = Object.assign(Object.create(null), opts.default);\n      var configObjects = opts.configObjects || [];\n      var envPrefix = opts.envPrefix;\n      var notFlagsOption = configuration['populate--'];\n      var notFlagsArgv = notFlagsOption ? '--' : '_';\n      var newAliases = Object.create(null);\n      var defaulted = Object.create(null); // allow a i18n handler to be passed in, default to a fake one (util.format).\n\n      var __ = opts.__ || mixin.format;\n\n      var flags = {\n        aliases: Object.create(null),\n        arrays: Object.create(null),\n        bools: Object.create(null),\n        strings: Object.create(null),\n        numbers: Object.create(null),\n        counts: Object.create(null),\n        normalize: Object.create(null),\n        configs: Object.create(null),\n        nargs: Object.create(null),\n        coercions: Object.create(null),\n        keys: []\n      };\n      var negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n      var negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n      [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {\n        var key = typeof opt === 'object' ? opt.key : opt; // assign to flags[bools|strings|numbers]\n\n        var assignment = Object.keys(opt).map(function (key) {\n          var arrayFlagKeys = {\n            boolean: 'bools',\n            string: 'strings',\n            number: 'numbers'\n          };\n          return arrayFlagKeys[key];\n        }).filter(Boolean).pop(); // assign key to be coerced\n\n        if (assignment) {\n          flags[assignment][key] = true;\n        }\n\n        flags.arrays[key] = true;\n        flags.keys.push(key);\n      });\n      [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {\n        flags.bools[key] = true;\n        flags.keys.push(key);\n      });\n      [].concat(opts.string || []).filter(Boolean).forEach(function (key) {\n        flags.strings[key] = true;\n        flags.keys.push(key);\n      });\n      [].concat(opts.number || []).filter(Boolean).forEach(function (key) {\n        flags.numbers[key] = true;\n        flags.keys.push(key);\n      });\n      [].concat(opts.count || []).filter(Boolean).forEach(function (key) {\n        flags.counts[key] = true;\n        flags.keys.push(key);\n      });\n      [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {\n        flags.normalize[key] = true;\n        flags.keys.push(key);\n      });\n\n      if (typeof opts.narg === 'object') {\n        Object.entries(opts.narg).forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              key = _ref2[0],\n              value = _ref2[1];\n\n          if (typeof value === 'number') {\n            flags.nargs[key] = value;\n            flags.keys.push(key);\n          }\n        });\n      }\n\n      if (typeof opts.coerce === 'object') {\n        Object.entries(opts.coerce).forEach(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              key = _ref4[0],\n              value = _ref4[1];\n\n          if (typeof value === 'function') {\n            flags.coercions[key] = value;\n            flags.keys.push(key);\n          }\n        });\n      }\n\n      if (typeof opts.config !== 'undefined') {\n        if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n          ;\n          [].concat(opts.config).filter(Boolean).forEach(function (key) {\n            flags.configs[key] = true;\n          });\n        } else if (typeof opts.config === 'object') {\n          Object.entries(opts.config).forEach(function (_ref5) {\n            var _ref6 = _slicedToArray(_ref5, 2),\n                key = _ref6[0],\n                value = _ref6[1];\n\n            if (typeof value === 'boolean' || typeof value === 'function') {\n              flags.configs[key] = value;\n            }\n          });\n        }\n      } // create a lookup table that takes into account all\n      // combinations of aliases: {f: ['foo'], foo: ['f']}\n\n\n      extendAliases(opts.key, aliases, opts.default, flags.arrays); // apply default values to all aliases.\n\n      Object.keys(defaults).forEach(function (key) {\n        (flags.aliases[key] || []).forEach(function (alias) {\n          defaults[alias] = defaults[key];\n        });\n      });\n      var error = null;\n      checkConfiguration();\n      var notFlags = [];\n      var argv = Object.assign(Object.create(null), {\n        _: []\n      }); // TODO(bcoe): for the first pass at removing object prototype  we didn't\n      // remove all prototypes from objects returned by this API, we might want\n      // to gradually move towards doing so.\n\n      var argvReturn = {};\n\n      for (var i = 0; i < args.length; i++) {\n        var arg = args[i];\n        var truncatedArg = arg.replace(/^-{3,}/, '---');\n        var broken = void 0;\n        var key = void 0;\n        var letters = void 0;\n        var m = void 0;\n        var next = void 0;\n        var value = void 0; // any unknown option (except for end-of-options, \"--\")\n\n        if (arg !== '--' && isUnknownOptionAsArg(arg)) {\n          pushPositional(arg); // ---, ---=, ----, etc,\n        } else if (truncatedArg.match(/---+(=|$)/)) {\n          // options without key name are invalid.\n          pushPositional(arg);\n          continue; // -- separated by =\n        } else if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {\n          // Using [\\s\\S] instead of . because js doesn't support the\n          // 'dotall' regex modifier. See:\n          // http://stackoverflow.com/a/1068308/13216\n          m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/); // arrays format = '--f=a b c'\n\n          if (m !== null && Array.isArray(m) && m.length >= 3) {\n            if (checkAllAliases(m[1], flags.arrays)) {\n              i = eatArray(i, m[1], args, m[2]);\n            } else if (checkAllAliases(m[1], flags.nargs) !== false) {\n              // nargs format = '--f=monkey washing cat'\n              i = eatNargs(i, m[1], args, m[2]);\n            } else {\n              setArg(m[1], m[2], true);\n            }\n          }\n        } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n          m = arg.match(negatedBoolean);\n\n          if (m !== null && Array.isArray(m) && m.length >= 2) {\n            key = m[1];\n            setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);\n          } // -- separated by space.\n\n        } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-[^-]+/)) {\n          m = arg.match(/^--?(.+)/);\n\n          if (m !== null && Array.isArray(m) && m.length >= 2) {\n            key = m[1];\n\n            if (checkAllAliases(key, flags.arrays)) {\n              // array format = '--foo a b c'\n              i = eatArray(i, key, args);\n            } else if (checkAllAliases(key, flags.nargs) !== false) {\n              // nargs format = '--foo a b c'\n              // should be truthy even if: flags.nargs[key] === 0\n              i = eatNargs(i, key, args);\n            } else {\n              next = args[i + 1];\n\n              if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n                setArg(key, next);\n                i++;\n              } else if (/^(true|false)$/.test(next)) {\n                setArg(key, next);\n                i++;\n              } else {\n                setArg(key, defaultValue(key));\n              }\n            }\n          } // dot-notation flag separated by '='.\n\n        } else if (arg.match(/^-.\\..+=/)) {\n          m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n\n          if (m !== null && Array.isArray(m) && m.length >= 3) {\n            setArg(m[1], m[2]);\n          } // dot-notation flag separated by space.\n\n        } else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n          next = args[i + 1];\n          m = arg.match(/^-(.\\..+)/);\n\n          if (m !== null && Array.isArray(m) && m.length >= 2) {\n            key = m[1];\n\n            if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n              setArg(key, next);\n              i++;\n            } else {\n              setArg(key, defaultValue(key));\n            }\n          }\n        } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n          letters = arg.slice(1, -1).split('');\n          broken = false;\n\n          for (var j = 0; j < letters.length; j++) {\n            next = arg.slice(j + 2);\n\n            if (letters[j + 1] && letters[j + 1] === '=') {\n              value = arg.slice(j + 3);\n              key = letters[j];\n\n              if (checkAllAliases(key, flags.arrays)) {\n                // array format = '-f=a b c'\n                i = eatArray(i, key, args, value);\n              } else if (checkAllAliases(key, flags.nargs) !== false) {\n                // nargs format = '-f=monkey washing cat'\n                i = eatNargs(i, key, args, value);\n              } else {\n                setArg(key, value);\n              }\n\n              broken = true;\n              break;\n            }\n\n            if (next === '-') {\n              setArg(letters[j], next);\n              continue;\n            } // current letter is an alphabetic character and next value is a number\n\n\n            if (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {\n              setArg(letters[j], next);\n              broken = true;\n              break;\n            }\n\n            if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n              setArg(letters[j], next);\n              broken = true;\n              break;\n            } else {\n              setArg(letters[j], defaultValue(letters[j]));\n            }\n          }\n\n          key = arg.slice(-1)[0];\n\n          if (!broken && key !== '-') {\n            if (checkAllAliases(key, flags.arrays)) {\n              // array format = '-f a b c'\n              i = eatArray(i, key, args);\n            } else if (checkAllAliases(key, flags.nargs) !== false) {\n              // nargs format = '-f a b c'\n              // should be truthy even if: flags.nargs[key] === 0\n              i = eatNargs(i, key, args);\n            } else {\n              next = args[i + 1];\n\n              if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n                setArg(key, next);\n                i++;\n              } else if (/^(true|false)$/.test(next)) {\n                setArg(key, next);\n                i++;\n              } else {\n                setArg(key, defaultValue(key));\n              }\n            }\n          }\n        } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {\n          // single-digit boolean alias, e.g: xargs -0\n          key = arg.slice(1);\n          setArg(key, defaultValue(key));\n        } else if (arg === '--') {\n          notFlags = args.slice(i + 1);\n          break;\n        } else if (configuration['halt-at-non-option']) {\n          notFlags = args.slice(i);\n          break;\n        } else {\n          pushPositional(arg);\n        }\n      } // order of precedence:\n      // 1. command line arg\n      // 2. value from env var\n      // 3. value from config file\n      // 4. value from config objects\n      // 5. configured default value\n\n\n      applyEnvVars(argv, true); // special case: check env vars that point to config file\n\n      applyEnvVars(argv, false);\n      setConfig(argv);\n      setConfigObjects();\n      applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n      applyCoercions(argv);\n      if (configuration['set-placeholder-key']) setPlaceholderKeys(argv); // for any counts either not in args or without an explicit default, set to 0\n\n      Object.keys(flags.counts).forEach(function (key) {\n        if (!hasKey(argv, key.split('.'))) setArg(key, 0);\n      }); // '--' defaults to undefined.\n\n      if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];\n      notFlags.forEach(function (key) {\n        argv[notFlagsArgv].push(key);\n      });\n\n      if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n        Object.keys(argv).filter(function (key) {\n          return key !== '--' && key.includes('-');\n        }).forEach(function (key) {\n          delete argv[key];\n        });\n      }\n\n      if (configuration['strip-aliased']) {\n        var _ref7;\n\n        ;\n\n        (_ref7 = []).concat.apply(_ref7, _toConsumableArray(Object.keys(aliases).map(function (k) {\n          return aliases[k];\n        }))).forEach(function (alias) {\n          if (configuration['camel-case-expansion'] && alias.includes('-')) {\n            delete argv[alias.split('.').map(function (prop) {\n              return camelCase(prop);\n            }).join('.')];\n          }\n\n          delete argv[alias];\n        });\n      } // Push argument into positional array, applying numeric coercion:\n\n\n      function pushPositional(arg) {\n        var maybeCoercedNumber = maybeCoerceNumber('_', arg);\n\n        if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {\n          argv._.push(maybeCoercedNumber);\n        }\n      } // how many arguments should we consume, based\n      // on the nargs option?\n\n\n      function eatNargs(i, key, args, argAfterEqualSign) {\n        var ii;\n        var toEat = checkAllAliases(key, flags.nargs); // NaN has a special meaning for the array type, indicating that one or\n        // more values are expected.\n\n        toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;\n\n        if (toEat === 0) {\n          if (!isUndefined(argAfterEqualSign)) {\n            error = Error(__('Argument unexpected for: %s', key));\n          }\n\n          setArg(key, defaultValue(key));\n          return i;\n        }\n\n        var available = isUndefined(argAfterEqualSign) ? 0 : 1;\n\n        if (configuration['nargs-eats-options']) {\n          // classic behavior, yargs eats positional and dash arguments.\n          if (args.length - (i + 1) + available < toEat) {\n            error = Error(__('Not enough arguments following: %s', key));\n          }\n\n          available = toEat;\n        } else {\n          // nargs will not consume flag arguments, e.g., -abc, --foo,\n          // and terminates when one is observed.\n          for (ii = i + 1; ii < args.length; ii++) {\n            if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;else break;\n          }\n\n          if (available < toEat) error = Error(__('Not enough arguments following: %s', key));\n        }\n\n        var consumed = Math.min(available, toEat);\n\n        if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n          setArg(key, argAfterEqualSign);\n          consumed--;\n        }\n\n        for (ii = i + 1; ii < consumed + i + 1; ii++) {\n          setArg(key, args[ii]);\n        }\n\n        return i + consumed;\n      } // if an option is an array, eat all non-hyphenated arguments\n      // following it... YUM!\n      // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n\n\n      function eatArray(i, key, args, argAfterEqualSign) {\n        var argsToSet = [];\n        var next = argAfterEqualSign || args[i + 1]; // If both array and nargs are configured, enforce the nargs count:\n\n        var nargsCount = checkAllAliases(key, flags.nargs);\n\n        if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {\n          argsToSet.push(true);\n        } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {\n          // for keys without value ==> argsToSet remains an empty []\n          // set user default value, if available\n          if (defaults[key] !== undefined) {\n            var defVal = defaults[key];\n            argsToSet = Array.isArray(defVal) ? defVal : [defVal];\n          }\n        } else {\n          // value in --option=value is eaten as is\n          if (!isUndefined(argAfterEqualSign)) {\n            argsToSet.push(processValue(key, argAfterEqualSign, true));\n          }\n\n          for (var ii = i + 1; ii < args.length; ii++) {\n            if (!configuration['greedy-arrays'] && argsToSet.length > 0 || nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount) break;\n            next = args[ii];\n            if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;\n            i = ii;\n            argsToSet.push(processValue(key, next, inputIsString));\n          }\n        } // If both array and nargs are configured, create an error if less than\n        // nargs positionals were found. NaN has special meaning, indicating\n        // that at least one value is required (more are okay).\n\n\n        if (typeof nargsCount === 'number' && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {\n          error = Error(__('Not enough arguments following: %s', key));\n        }\n\n        setArg(key, argsToSet);\n        return i;\n      }\n\n      function setArg(key, val) {\n        var shouldStripQuotes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : inputIsString;\n\n        if (/-/.test(key) && configuration['camel-case-expansion']) {\n          var alias = key.split('.').map(function (prop) {\n            return camelCase(prop);\n          }).join('.');\n          addNewAlias(key, alias);\n        }\n\n        var value = processValue(key, val, shouldStripQuotes);\n        var splitKey = key.split('.');\n        setKey(argv, splitKey, value); // handle populating aliases of the full key\n\n        if (flags.aliases[key]) {\n          flags.aliases[key].forEach(function (x) {\n            var keyProperties = x.split('.');\n            setKey(argv, keyProperties, value);\n          });\n        } // handle populating aliases of the first element of the dot-notation key\n\n\n        if (splitKey.length > 1 && configuration['dot-notation']) {\n          ;\n          (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n            var keyProperties = x.split('.'); // expand alias with nested objects in key\n\n            var a = [].concat(splitKey);\n            a.shift(); // nuke the old key.\n\n            keyProperties = keyProperties.concat(a); // populate alias only if is not already an alias of the full key\n            // (already populated above)\n\n            if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {\n              setKey(argv, keyProperties, value);\n            }\n          });\n        } // Set normalize getter and setter when key is in 'normalize' but isn't an array\n\n\n        if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n          var keys = [key].concat(flags.aliases[key] || []);\n          keys.forEach(function (key) {\n            Object.defineProperty(argvReturn, key, {\n              enumerable: true,\n              get: function get() {\n                return val;\n              },\n              set: function set(value) {\n                val = typeof value === 'string' ? mixin.normalize(value) : value;\n              }\n            });\n          });\n        }\n      }\n\n      function addNewAlias(key, alias) {\n        if (!(flags.aliases[key] && flags.aliases[key].length)) {\n          flags.aliases[key] = [alias];\n          newAliases[alias] = true;\n        }\n\n        if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n          addNewAlias(alias, key);\n        }\n      }\n\n      function processValue(key, val, shouldStripQuotes) {\n        // strings may be quoted, clean this up as we assign values.\n        if (shouldStripQuotes) {\n          val = stripQuotes(val);\n        } // handle parsing boolean arguments --foo=true --bar false.\n\n\n        if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n          if (typeof val === 'string') val = val === 'true';\n        }\n\n        var value = Array.isArray(val) ? val.map(function (v) {\n          return maybeCoerceNumber(key, v);\n        }) : maybeCoerceNumber(key, val); // increment a count given as arg (either no value or value parsed as boolean)\n\n        if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n          value = increment();\n        } // Set normalized value when key is in 'normalize' and in 'arrays'\n\n\n        if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n          if (Array.isArray(val)) value = val.map(function (val) {\n            return mixin.normalize(val);\n          });else value = mixin.normalize(val);\n        }\n\n        return value;\n      }\n\n      function maybeCoerceNumber(key, value) {\n        if (!configuration['parse-positional-numbers'] && key === '_') return value;\n\n        if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n          var shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(parseFloat(\"\".concat(value))));\n\n          if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {\n            value = Number(value);\n          }\n        }\n\n        return value;\n      } // set args from config.json file, this should be\n      // applied last so that defaults can be applied.\n\n\n      function setConfig(argv) {\n        var configLookup = Object.create(null); // expand defaults/aliases, in-case any happen to reference\n        // the config.json file.\n\n        applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n        Object.keys(flags.configs).forEach(function (configKey) {\n          var configPath = argv[configKey] || configLookup[configKey];\n\n          if (configPath) {\n            try {\n              var config = null;\n              var resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);\n              var resolveConfig = flags.configs[configKey];\n\n              if (typeof resolveConfig === 'function') {\n                try {\n                  config = resolveConfig(resolvedConfigPath);\n                } catch (e) {\n                  config = e;\n                }\n\n                if (config instanceof Error) {\n                  error = config;\n                  return;\n                }\n              } else {\n                config = mixin.require(resolvedConfigPath);\n              }\n\n              setConfigObject(config);\n            } catch (ex) {\n              // Deno will receive a PermissionDenied error if an attempt is\n              // made to load config without the --allow-read flag:\n              if (ex.name === 'PermissionDenied') error = ex;else if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));\n            }\n          }\n        });\n      } // set args from config object.\n      // it recursively checks nested objects.\n\n\n      function setConfigObject(config, prev) {\n        Object.keys(config).forEach(function (key) {\n          var value = config[key];\n          var fullKey = prev ? prev + '.' + key : key; // if the value is an inner object and we have dot-notation\n          // enabled, treat inner objects in config the same as\n          // heavily nested dot notations (foo.bar.apple).\n\n          if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n            // if the value is an object but not an array, check nested object\n            setConfigObject(value, fullKey);\n          } else {\n            // setting arguments via CLI takes precedence over\n            // values within the config file.\n            if (!hasKey(argv, fullKey.split('.')) || checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays']) {\n              setArg(fullKey, value);\n            }\n          }\n        });\n      } // set all config objects passed in opts\n\n\n      function setConfigObjects() {\n        if (typeof configObjects !== 'undefined') {\n          configObjects.forEach(function (configObject) {\n            setConfigObject(configObject);\n          });\n        }\n      }\n\n      function applyEnvVars(argv, configOnly) {\n        if (typeof envPrefix === 'undefined') return;\n        var prefix = typeof envPrefix === 'string' ? envPrefix : '';\n        var env = mixin.env();\n        Object.keys(env).forEach(function (envVar) {\n          if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n            // get array of nested keys and convert them to camel case\n            var keys = envVar.split('__').map(function (key, i) {\n              if (i === 0) {\n                key = key.substring(prefix.length);\n              }\n\n              return camelCase(key);\n            });\n\n            if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && !hasKey(argv, keys)) {\n              setArg(keys.join('.'), env[envVar]);\n            }\n          }\n        });\n      }\n\n      function applyCoercions(argv) {\n        var coerce;\n        var applied = new Set();\n        Object.keys(argv).forEach(function (key) {\n          if (!applied.has(key)) {\n            // If we haven't already coerced this option via one of its aliases\n            coerce = checkAllAliases(key, flags.coercions);\n\n            if (typeof coerce === 'function') {\n              try {\n                var _value = maybeCoerceNumber(key, coerce(argv[key]));\n\n                [].concat(flags.aliases[key] || [], key).forEach(function (ali) {\n                  applied.add(ali);\n                  argv[ali] = _value;\n                });\n              } catch (err) {\n                error = err;\n              }\n            }\n          }\n        });\n      }\n\n      function setPlaceholderKeys(argv) {\n        flags.keys.forEach(function (key) {\n          // don't set placeholder keys for dot notation options 'foo.bar'.\n          if (~key.indexOf('.')) return;\n          if (typeof argv[key] === 'undefined') argv[key] = undefined;\n        });\n        return argv;\n      }\n\n      function applyDefaultsAndAliases(obj, aliases, defaults) {\n        var canLog = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        Object.keys(defaults).forEach(function (key) {\n          if (!hasKey(obj, key.split('.'))) {\n            setKey(obj, key.split('.'), defaults[key]);\n            if (canLog) defaulted[key] = true;\n            (aliases[key] || []).forEach(function (x) {\n              if (hasKey(obj, x.split('.'))) return;\n              setKey(obj, x.split('.'), defaults[key]);\n            });\n          }\n        });\n      }\n\n      function hasKey(obj, keys) {\n        var o = obj;\n        if (!configuration['dot-notation']) keys = [keys.join('.')];\n        keys.slice(0, -1).forEach(function (key) {\n          o = o[key] || {};\n        });\n        var key = keys[keys.length - 1];\n        if (typeof o !== 'object') return false;else return key in o;\n      }\n\n      function setKey(obj, keys, value) {\n        var o = obj;\n        if (!configuration['dot-notation']) keys = [keys.join('.')];\n        keys.slice(0, -1).forEach(function (key) {\n          // TODO(bcoe): in the next major version of yargs, switch to\n          // Object.create(null) for dot notation:\n          key = sanitizeKey(key);\n\n          if (typeof o === 'object' && o[key] === undefined) {\n            o[key] = {};\n          }\n\n          if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n            // ensure that o[key] is an array, and that the last item is an empty object.\n            if (Array.isArray(o[key])) {\n              o[key].push({});\n            } else {\n              o[key] = [o[key], {}];\n            } // we want to update the empty object at the end of the o[key] array, so set o to that object\n\n\n            o = o[key][o[key].length - 1];\n          } else {\n            o = o[key];\n          }\n        }); // TODO(bcoe): in the next major version of yargs, switch to\n        // Object.create(null) for dot notation:\n\n        var key = sanitizeKey(keys[keys.length - 1]);\n        var isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n        var isValueArray = Array.isArray(value);\n        var duplicate = configuration['duplicate-arguments-array']; // nargs has higher priority than duplicate\n\n        if (!duplicate && checkAllAliases(key, flags.nargs)) {\n          duplicate = true;\n\n          if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {\n            o[key] = undefined;\n          }\n        }\n\n        if (value === increment()) {\n          o[key] = increment(o[key]);\n        } else if (Array.isArray(o[key])) {\n          if (duplicate && isTypeArray && isValueArray) {\n            o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n          } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n            o[key] = value;\n          } else {\n            o[key] = o[key].concat([value]);\n          }\n        } else if (o[key] === undefined && isTypeArray) {\n          o[key] = isValueArray ? value : [value];\n        } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {\n          o[key] = [o[key], value];\n        } else {\n          o[key] = value;\n        }\n      } // extend the aliases list with inferred aliases.\n\n\n      function extendAliases() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        args.forEach(function (obj) {\n          Object.keys(obj || {}).forEach(function (key) {\n            // short-circuit if we've already added a key\n            // to the aliases array, for example it might\n            // exist in both 'opts.default' and 'opts.key'.\n            if (flags.aliases[key]) return;\n            flags.aliases[key] = [].concat(aliases[key] || []); // For \"--option-name\", also set argv.optionName\n\n            flags.aliases[key].concat(key).forEach(function (x) {\n              if (/-/.test(x) && configuration['camel-case-expansion']) {\n                var c = camelCase(x);\n\n                if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                  flags.aliases[key].push(c);\n                  newAliases[c] = true;\n                }\n              }\n            }); // For \"--optionName\", also set argv['option-name']\n\n            flags.aliases[key].concat(key).forEach(function (x) {\n              if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n                var c = decamelize(x, '-');\n\n                if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                  flags.aliases[key].push(c);\n                  newAliases[c] = true;\n                }\n              }\n            });\n            flags.aliases[key].forEach(function (x) {\n              flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n                return x !== y;\n              }));\n            });\n          });\n        });\n      }\n\n      function checkAllAliases(key, flag) {\n        var toCheck = [].concat(flags.aliases[key] || [], key);\n        var keys = Object.keys(flag);\n        var setAlias = toCheck.find(function (key) {\n          return keys.includes(key);\n        });\n        return setAlias ? flag[setAlias] : false;\n      }\n\n      function hasAnyFlag(key) {\n        var flagsKeys = Object.keys(flags);\n        var toCheck = [].concat(flagsKeys.map(function (k) {\n          return flags[k];\n        }));\n        return toCheck.some(function (flag) {\n          return Array.isArray(flag) ? flag.includes(key) : flag[key];\n        });\n      }\n\n      function hasFlagsMatching(arg) {\n        var _ref8;\n\n        for (var _len2 = arguments.length, patterns = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          patterns[_key2 - 1] = arguments[_key2];\n        }\n\n        var toCheck = (_ref8 = []).concat.apply(_ref8, patterns);\n\n        return toCheck.some(function (pattern) {\n          var match = arg.match(pattern);\n          return match && hasAnyFlag(match[1]);\n        });\n      } // based on a simplified version of the short flag group parsing logic\n\n\n      function hasAllShortFlags(arg) {\n        // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n        if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n          return false;\n        }\n\n        var hasAllFlags = true;\n        var next;\n        var letters = arg.slice(1).split('');\n\n        for (var _j = 0; _j < letters.length; _j++) {\n          next = arg.slice(_j + 2);\n\n          if (!hasAnyFlag(letters[_j])) {\n            hasAllFlags = false;\n            break;\n          }\n\n          if (letters[_j + 1] && letters[_j + 1] === '=' || next === '-' || /[A-Za-z]/.test(letters[_j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) || letters[_j + 1] && letters[_j + 1].match(/\\W/)) {\n            break;\n          }\n        }\n\n        return hasAllFlags;\n      }\n\n      function isUnknownOptionAsArg(arg) {\n        return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n      }\n\n      function isUnknownOption(arg) {\n        arg = arg.replace(/^-{3,}/, '--'); // ignore negative numbers\n\n        if (arg.match(negative)) {\n          return false;\n        } // if this is a short option group and all of them are configured, it isn't unknown\n\n\n        if (hasAllShortFlags(arg)) {\n          return false;\n        } // e.g. '--count=2'\n\n\n        var flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/; // e.g. '-a' or '--arg'\n\n        var normalFlag = /^-+([^=]+?)$/; // e.g. '-a-'\n\n        var flagEndingInHyphen = /^-+([^=]+?)-$/; // e.g. '-abc123'\n\n        var flagEndingInDigits = /^-+([^=]+?\\d+)$/; // e.g. '-a/usr/local'\n\n        var flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/; // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n\n        return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n      } // make a best effort to pick a default value\n      // for an option based on name and type.\n\n\n      function defaultValue(key) {\n        if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && \"\".concat(key) in defaults) {\n          return defaults[key];\n        } else {\n          return defaultForType(guessType(key));\n        }\n      } // return a default value, given the type of a flag.,\n\n\n      function defaultForType(type) {\n        var _def;\n\n        var def = (_def = {}, _defineProperty(_def, DefaultValuesForTypeKey.BOOLEAN, true), _defineProperty(_def, DefaultValuesForTypeKey.STRING, ''), _defineProperty(_def, DefaultValuesForTypeKey.NUMBER, undefined), _defineProperty(_def, DefaultValuesForTypeKey.ARRAY, []), _def);\n        return def[type];\n      } // given a flag, enforce a default type.\n\n\n      function guessType(key) {\n        var type = DefaultValuesForTypeKey.BOOLEAN;\n        if (checkAllAliases(key, flags.strings)) type = DefaultValuesForTypeKey.STRING;else if (checkAllAliases(key, flags.numbers)) type = DefaultValuesForTypeKey.NUMBER;else if (checkAllAliases(key, flags.bools)) type = DefaultValuesForTypeKey.BOOLEAN;else if (checkAllAliases(key, flags.arrays)) type = DefaultValuesForTypeKey.ARRAY;\n        return type;\n      }\n\n      function isUndefined(num) {\n        return num === undefined;\n      } // check user configuration settings for inconsistencies\n\n\n      function checkConfiguration() {\n        // count keys should not be set as array/narg\n        Object.keys(flags.counts).find(function (key) {\n          if (checkAllAliases(key, flags.arrays)) {\n            error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));\n            return true;\n          } else if (checkAllAliases(key, flags.nargs)) {\n            error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));\n            return true;\n          }\n\n          return false;\n        });\n      }\n\n      return {\n        aliases: Object.assign({}, flags.aliases),\n        argv: Object.assign(argvReturn, argv),\n        configuration: configuration,\n        defaulted: Object.assign({}, defaulted),\n        error: error,\n        newAliases: Object.assign({}, newAliases)\n      };\n    }\n  }]);\n\n  return YargsParser;\n}(); // if any aliases reference each other, we should\n// merge them together.\n\nfunction combineAliases(aliases) {\n  var aliasArrays = [];\n  var combined = Object.create(null);\n  var change = true; // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push([].concat(aliases[key], key));\n  }); // combine arrays until zero changes are\n  // made in an iteration.\n\n  while (change) {\n    change = false;\n\n    for (var i = 0; i < aliasArrays.length; i++) {\n      var _loop = function _loop(ii) {\n        var intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1;\n        });\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n          aliasArrays.splice(ii, 1);\n          change = true;\n          return \"break\";\n        }\n      };\n\n      for (var ii = i + 1; ii < aliasArrays.length; ii++) {\n        var _ret = _loop(ii);\n\n        if (_ret === \"break\") break;\n      }\n    }\n  } // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n\n\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i;\n    });\n    var lastAlias = aliasArray.pop();\n\n    if (lastAlias !== undefined && typeof lastAlias === 'string') {\n      combined[lastAlias] = aliasArray;\n    }\n  });\n  return combined;\n} // this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\n\n\nfunction increment(orig) {\n  return orig !== undefined ? orig + 1 : 1;\n} // TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\n\n\nfunction sanitizeKey(key) {\n  if (key === '__proto__') return '___proto___';\n  return key;\n}\n\nfunction stripQuotes(val) {\n  return typeof val === 'string' && (val[0] === \"'\" || val[0] === '\"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;\n}","map":{"version":3,"names":["tokenizeArgString","DefaultValuesForTypeKey","camelCase","decamelize","looksLikeNumber","mixin","YargsParser","_mixin","argsInput","options","opts","Object","assign","alias","undefined","array","boolean","config","configObjects","configuration","coerce","count","default","envPrefix","narg","normalize","string","number","__","key","args","inputIsString","aliases","combineAliases","create","defaults","notFlagsOption","notFlagsArgv","newAliases","defaulted","format","flags","arrays","bools","strings","numbers","counts","configs","nargs","coercions","keys","negative","negatedBoolean","RegExp","concat","filter","Boolean","forEach","opt","assignment","map","arrayFlagKeys","pop","push","entries","value","Array","isArray","extendAliases","error","checkConfiguration","notFlags","argv","_","argvReturn","i","length","arg","truncatedArg","replace","broken","letters","m","next","isUnknownOptionAsArg","pushPositional","match","checkAllAliases","eatArray","eatNargs","setArg","test","defaultValue","slice","split","j","applyEnvVars","setConfig","setConfigObjects","applyDefaultsAndAliases","applyCoercions","setPlaceholderKeys","hasKey","includes","k","prop","join","maybeCoercedNumber","maybeCoerceNumber","argAfterEqualSign","ii","toEat","isNaN","isUndefined","Error","available","consumed","Math","min","argsToSet","nargsCount","defVal","processValue","val","shouldStripQuotes","addNewAlias","splitKey","setKey","x","keyProperties","a","shift","defineProperty","enumerable","get","set","stripQuotes","v","increment","shouldCoerceNumber","Number","isSafeInteger","floor","parseFloat","configLookup","configKey","configPath","resolvedConfigPath","resolve","cwd","resolveConfig","e","require","setConfigObject","ex","name","prev","fullKey","configObject","configOnly","prefix","env","envVar","lastIndexOf","substring","applied","Set","has","ali","add","err","indexOf","obj","canLog","o","sanitizeKey","isTypeArray","isValueArray","duplicate","c","y","flag","toCheck","setAlias","find","hasAnyFlag","flagsKeys","some","hasFlagsMatching","patterns","pattern","hasAllShortFlags","hasAllFlags","isUnknownOption","flagWithEquals","normalFlag","flagEndingInHyphen","flagEndingInDigits","flagEndingInNonWordCharacters","defaultForType","guessType","type","def","BOOLEAN","STRING","NUMBER","ARRAY","num","aliasArrays","combined","change","intersect","splice","aliasArray","self","lastAlias","orig"],"sources":["/Users/mu.../Documents/Boolean/React/WeatherApp/node_modules/yargs-parser/build/lib/yargs-parser.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */\nimport { tokenizeArgString } from './tokenize-arg-string.js';\nimport { DefaultValuesForTypeKey } from './yargs-parser-types.js';\nimport { camelCase, decamelize, looksLikeNumber } from './string-utils.js';\nlet mixin;\nexport class YargsParser {\n    constructor(_mixin) {\n        mixin = _mixin;\n    }\n    parse(argsInput, options) {\n        const opts = Object.assign({\n            alias: undefined,\n            array: undefined,\n            boolean: undefined,\n            config: undefined,\n            configObjects: undefined,\n            configuration: undefined,\n            coerce: undefined,\n            count: undefined,\n            default: undefined,\n            envPrefix: undefined,\n            narg: undefined,\n            normalize: undefined,\n            string: undefined,\n            number: undefined,\n            __: undefined,\n            key: undefined\n        }, options);\n        // allow a string argument to be passed in rather\n        // than an argv array.\n        const args = tokenizeArgString(argsInput);\n        // tokenizeArgString adds extra quotes to args if argsInput is a string\n        // only strip those extra quotes in processValue if argsInput is a string\n        const inputIsString = typeof argsInput === 'string';\n        // aliases might have transitive relationships, normalize this.\n        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n        const configuration = Object.assign({\n            'boolean-negation': true,\n            'camel-case-expansion': true,\n            'combine-arrays': false,\n            'dot-notation': true,\n            'duplicate-arguments-array': true,\n            'flatten-duplicate-arrays': true,\n            'greedy-arrays': true,\n            'halt-at-non-option': false,\n            'nargs-eats-options': false,\n            'negation-prefix': 'no-',\n            'parse-numbers': true,\n            'parse-positional-numbers': true,\n            'populate--': false,\n            'set-placeholder-key': false,\n            'short-option-groups': true,\n            'strip-aliased': false,\n            'strip-dashed': false,\n            'unknown-options-as-args': false\n        }, opts.configuration);\n        const defaults = Object.assign(Object.create(null), opts.default);\n        const configObjects = opts.configObjects || [];\n        const envPrefix = opts.envPrefix;\n        const notFlagsOption = configuration['populate--'];\n        const notFlagsArgv = notFlagsOption ? '--' : '_';\n        const newAliases = Object.create(null);\n        const defaulted = Object.create(null);\n        // allow a i18n handler to be passed in, default to a fake one (util.format).\n        const __ = opts.__ || mixin.format;\n        const flags = {\n            aliases: Object.create(null),\n            arrays: Object.create(null),\n            bools: Object.create(null),\n            strings: Object.create(null),\n            numbers: Object.create(null),\n            counts: Object.create(null),\n            normalize: Object.create(null),\n            configs: Object.create(null),\n            nargs: Object.create(null),\n            coercions: Object.create(null),\n            keys: []\n        };\n        const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {\n            const key = typeof opt === 'object' ? opt.key : opt;\n            // assign to flags[bools|strings|numbers]\n            const assignment = Object.keys(opt).map(function (key) {\n                const arrayFlagKeys = {\n                    boolean: 'bools',\n                    string: 'strings',\n                    number: 'numbers'\n                };\n                return arrayFlagKeys[key];\n            }).filter(Boolean).pop();\n            // assign key to be coerced\n            if (assignment) {\n                flags[assignment][key] = true;\n            }\n            flags.arrays[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {\n            flags.bools[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.string || []).filter(Boolean).forEach(function (key) {\n            flags.strings[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.number || []).filter(Boolean).forEach(function (key) {\n            flags.numbers[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.count || []).filter(Boolean).forEach(function (key) {\n            flags.counts[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {\n            flags.normalize[key] = true;\n            flags.keys.push(key);\n        });\n        if (typeof opts.narg === 'object') {\n            Object.entries(opts.narg).forEach(([key, value]) => {\n                if (typeof value === 'number') {\n                    flags.nargs[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.coerce === 'object') {\n            Object.entries(opts.coerce).forEach(([key, value]) => {\n                if (typeof value === 'function') {\n                    flags.coercions[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.config !== 'undefined') {\n            if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n                ;\n                [].concat(opts.config).filter(Boolean).forEach(function (key) {\n                    flags.configs[key] = true;\n                });\n            }\n            else if (typeof opts.config === 'object') {\n                Object.entries(opts.config).forEach(([key, value]) => {\n                    if (typeof value === 'boolean' || typeof value === 'function') {\n                        flags.configs[key] = value;\n                    }\n                });\n            }\n        }\n        // create a lookup table that takes into account all\n        // combinations of aliases: {f: ['foo'], foo: ['f']}\n        extendAliases(opts.key, aliases, opts.default, flags.arrays);\n        // apply default values to all aliases.\n        Object.keys(defaults).forEach(function (key) {\n            (flags.aliases[key] || []).forEach(function (alias) {\n                defaults[alias] = defaults[key];\n            });\n        });\n        let error = null;\n        checkConfiguration();\n        let notFlags = [];\n        const argv = Object.assign(Object.create(null), { _: [] });\n        // TODO(bcoe): for the first pass at removing object prototype  we didn't\n        // remove all prototypes from objects returned by this API, we might want\n        // to gradually move towards doing so.\n        const argvReturn = {};\n        for (let i = 0; i < args.length; i++) {\n            const arg = args[i];\n            const truncatedArg = arg.replace(/^-{3,}/, '---');\n            let broken;\n            let key;\n            let letters;\n            let m;\n            let next;\n            let value;\n            // any unknown option (except for end-of-options, \"--\")\n            if (arg !== '--' && isUnknownOptionAsArg(arg)) {\n                pushPositional(arg);\n                // ---, ---=, ----, etc,\n            }\n            else if (truncatedArg.match(/---+(=|$)/)) {\n                // options without key name are invalid.\n                pushPositional(arg);\n                continue;\n                // -- separated by =\n            }\n            else if (arg.match(/^--.+=/) || (!configuration['short-option-groups'] && arg.match(/^-.+=/))) {\n                // Using [\\s\\S] instead of . because js doesn't support the\n                // 'dotall' regex modifier. See:\n                // http://stackoverflow.com/a/1068308/13216\n                m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/);\n                // arrays format = '--f=a b c'\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    if (checkAllAliases(m[1], flags.arrays)) {\n                        i = eatArray(i, m[1], args, m[2]);\n                    }\n                    else if (checkAllAliases(m[1], flags.nargs) !== false) {\n                        // nargs format = '--f=monkey washing cat'\n                        i = eatNargs(i, m[1], args, m[2]);\n                    }\n                    else {\n                        setArg(m[1], m[2], true);\n                    }\n                }\n            }\n            else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n                m = arg.match(negatedBoolean);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);\n                }\n                // -- separated by space.\n            }\n            else if (arg.match(/^--.+/) || (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))) {\n                m = arg.match(/^--?(.+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (checkAllAliases(key, flags.arrays)) {\n                        // array format = '--foo a b c'\n                        i = eatArray(i, key, args);\n                    }\n                    else if (checkAllAliases(key, flags.nargs) !== false) {\n                        // nargs format = '--foo a b c'\n                        // should be truthy even if: flags.nargs[key] === 0\n                        i = eatNargs(i, key, args);\n                    }\n                    else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!next.match(/^-/) ||\n                            next.match(negative)) &&\n                            !checkAllAliases(key, flags.bools) &&\n                            !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n                // dot-notation flag separated by '='.\n            }\n            else if (arg.match(/^-.\\..+=/)) {\n                m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    setArg(m[1], m[2]);\n                }\n                // dot-notation flag separated by space.\n            }\n            else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n                next = args[i + 1];\n                m = arg.match(/^-(.\\..+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (next !== undefined && !next.match(/^-/) &&\n                        !checkAllAliases(key, flags.bools) &&\n                        !checkAllAliases(key, flags.counts)) {\n                        setArg(key, next);\n                        i++;\n                    }\n                    else {\n                        setArg(key, defaultValue(key));\n                    }\n                }\n            }\n            else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n                letters = arg.slice(1, -1).split('');\n                broken = false;\n                for (let j = 0; j < letters.length; j++) {\n                    next = arg.slice(j + 2);\n                    if (letters[j + 1] && letters[j + 1] === '=') {\n                        value = arg.slice(j + 3);\n                        key = letters[j];\n                        if (checkAllAliases(key, flags.arrays)) {\n                            // array format = '-f=a b c'\n                            i = eatArray(i, key, args, value);\n                        }\n                        else if (checkAllAliases(key, flags.nargs) !== false) {\n                            // nargs format = '-f=monkey washing cat'\n                            i = eatNargs(i, key, args, value);\n                        }\n                        else {\n                            setArg(key, value);\n                        }\n                        broken = true;\n                        break;\n                    }\n                    if (next === '-') {\n                        setArg(letters[j], next);\n                        continue;\n                    }\n                    // current letter is an alphabetic character and next value is a number\n                    if (/[A-Za-z]/.test(letters[j]) &&\n                        /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) &&\n                        checkAllAliases(next, flags.bools) === false) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    else {\n                        setArg(letters[j], defaultValue(letters[j]));\n                    }\n                }\n                key = arg.slice(-1)[0];\n                if (!broken && key !== '-') {\n                    if (checkAllAliases(key, flags.arrays)) {\n                        // array format = '-f a b c'\n                        i = eatArray(i, key, args);\n                    }\n                    else if (checkAllAliases(key, flags.nargs) !== false) {\n                        // nargs format = '-f a b c'\n                        // should be truthy even if: flags.nargs[key] === 0\n                        i = eatNargs(i, key, args);\n                    }\n                    else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n                            next.match(negative)) &&\n                            !checkAllAliases(key, flags.bools) &&\n                            !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n            }\n            else if (arg.match(/^-[0-9]$/) &&\n                arg.match(negative) &&\n                checkAllAliases(arg.slice(1), flags.bools)) {\n                // single-digit boolean alias, e.g: xargs -0\n                key = arg.slice(1);\n                setArg(key, defaultValue(key));\n            }\n            else if (arg === '--') {\n                notFlags = args.slice(i + 1);\n                break;\n            }\n            else if (configuration['halt-at-non-option']) {\n                notFlags = args.slice(i);\n                break;\n            }\n            else {\n                pushPositional(arg);\n            }\n        }\n        // order of precedence:\n        // 1. command line arg\n        // 2. value from env var\n        // 3. value from config file\n        // 4. value from config objects\n        // 5. configured default value\n        applyEnvVars(argv, true); // special case: check env vars that point to config file\n        applyEnvVars(argv, false);\n        setConfig(argv);\n        setConfigObjects();\n        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n        applyCoercions(argv);\n        if (configuration['set-placeholder-key'])\n            setPlaceholderKeys(argv);\n        // for any counts either not in args or without an explicit default, set to 0\n        Object.keys(flags.counts).forEach(function (key) {\n            if (!hasKey(argv, key.split('.')))\n                setArg(key, 0);\n        });\n        // '--' defaults to undefined.\n        if (notFlagsOption && notFlags.length)\n            argv[notFlagsArgv] = [];\n        notFlags.forEach(function (key) {\n            argv[notFlagsArgv].push(key);\n        });\n        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n            Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n                delete argv[key];\n            });\n        }\n        if (configuration['strip-aliased']) {\n            ;\n            [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n                if (configuration['camel-case-expansion'] && alias.includes('-')) {\n                    delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];\n                }\n                delete argv[alias];\n            });\n        }\n        // Push argument into positional array, applying numeric coercion:\n        function pushPositional(arg) {\n            const maybeCoercedNumber = maybeCoerceNumber('_', arg);\n            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {\n                argv._.push(maybeCoercedNumber);\n            }\n        }\n        // how many arguments should we consume, based\n        // on the nargs option?\n        function eatNargs(i, key, args, argAfterEqualSign) {\n            let ii;\n            let toEat = checkAllAliases(key, flags.nargs);\n            // NaN has a special meaning for the array type, indicating that one or\n            // more values are expected.\n            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;\n            if (toEat === 0) {\n                if (!isUndefined(argAfterEqualSign)) {\n                    error = Error(__('Argument unexpected for: %s', key));\n                }\n                setArg(key, defaultValue(key));\n                return i;\n            }\n            let available = isUndefined(argAfterEqualSign) ? 0 : 1;\n            if (configuration['nargs-eats-options']) {\n                // classic behavior, yargs eats positional and dash arguments.\n                if (args.length - (i + 1) + available < toEat) {\n                    error = Error(__('Not enough arguments following: %s', key));\n                }\n                available = toEat;\n            }\n            else {\n                // nargs will not consume flag arguments, e.g., -abc, --foo,\n                // and terminates when one is observed.\n                for (ii = i + 1; ii < args.length; ii++) {\n                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))\n                        available++;\n                    else\n                        break;\n                }\n                if (available < toEat)\n                    error = Error(__('Not enough arguments following: %s', key));\n            }\n            let consumed = Math.min(available, toEat);\n            if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n                setArg(key, argAfterEqualSign);\n                consumed--;\n            }\n            for (ii = i + 1; ii < (consumed + i + 1); ii++) {\n                setArg(key, args[ii]);\n            }\n            return (i + consumed);\n        }\n        // if an option is an array, eat all non-hyphenated arguments\n        // following it... YUM!\n        // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n        function eatArray(i, key, args, argAfterEqualSign) {\n            let argsToSet = [];\n            let next = argAfterEqualSign || args[i + 1];\n            // If both array and nargs are configured, enforce the nargs count:\n            const nargsCount = checkAllAliases(key, flags.nargs);\n            if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {\n                argsToSet.push(true);\n            }\n            else if (isUndefined(next) ||\n                (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {\n                // for keys without value ==> argsToSet remains an empty []\n                // set user default value, if available\n                if (defaults[key] !== undefined) {\n                    const defVal = defaults[key];\n                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];\n                }\n            }\n            else {\n                // value in --option=value is eaten as is\n                if (!isUndefined(argAfterEqualSign)) {\n                    argsToSet.push(processValue(key, argAfterEqualSign, true));\n                }\n                for (let ii = i + 1; ii < args.length; ii++) {\n                    if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||\n                        (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount))\n                        break;\n                    next = args[ii];\n                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))\n                        break;\n                    i = ii;\n                    argsToSet.push(processValue(key, next, inputIsString));\n                }\n            }\n            // If both array and nargs are configured, create an error if less than\n            // nargs positionals were found. NaN has special meaning, indicating\n            // that at least one value is required (more are okay).\n            if (typeof nargsCount === 'number' && ((nargsCount && argsToSet.length < nargsCount) ||\n                (isNaN(nargsCount) && argsToSet.length === 0))) {\n                error = Error(__('Not enough arguments following: %s', key));\n            }\n            setArg(key, argsToSet);\n            return i;\n        }\n        function setArg(key, val, shouldStripQuotes = inputIsString) {\n            if (/-/.test(key) && configuration['camel-case-expansion']) {\n                const alias = key.split('.').map(function (prop) {\n                    return camelCase(prop);\n                }).join('.');\n                addNewAlias(key, alias);\n            }\n            const value = processValue(key, val, shouldStripQuotes);\n            const splitKey = key.split('.');\n            setKey(argv, splitKey, value);\n            // handle populating aliases of the full key\n            if (flags.aliases[key]) {\n                flags.aliases[key].forEach(function (x) {\n                    const keyProperties = x.split('.');\n                    setKey(argv, keyProperties, value);\n                });\n            }\n            // handle populating aliases of the first element of the dot-notation key\n            if (splitKey.length > 1 && configuration['dot-notation']) {\n                ;\n                (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n                    let keyProperties = x.split('.');\n                    // expand alias with nested objects in key\n                    const a = [].concat(splitKey);\n                    a.shift(); // nuke the old key.\n                    keyProperties = keyProperties.concat(a);\n                    // populate alias only if is not already an alias of the full key\n                    // (already populated above)\n                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {\n                        setKey(argv, keyProperties, value);\n                    }\n                });\n            }\n            // Set normalize getter and setter when key is in 'normalize' but isn't an array\n            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n                const keys = [key].concat(flags.aliases[key] || []);\n                keys.forEach(function (key) {\n                    Object.defineProperty(argvReturn, key, {\n                        enumerable: true,\n                        get() {\n                            return val;\n                        },\n                        set(value) {\n                            val = typeof value === 'string' ? mixin.normalize(value) : value;\n                        }\n                    });\n                });\n            }\n        }\n        function addNewAlias(key, alias) {\n            if (!(flags.aliases[key] && flags.aliases[key].length)) {\n                flags.aliases[key] = [alias];\n                newAliases[alias] = true;\n            }\n            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n                addNewAlias(alias, key);\n            }\n        }\n        function processValue(key, val, shouldStripQuotes) {\n            // strings may be quoted, clean this up as we assign values.\n            if (shouldStripQuotes) {\n                val = stripQuotes(val);\n            }\n            // handle parsing boolean arguments --foo=true --bar false.\n            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n                if (typeof val === 'string')\n                    val = val === 'true';\n            }\n            let value = Array.isArray(val)\n                ? val.map(function (v) { return maybeCoerceNumber(key, v); })\n                : maybeCoerceNumber(key, val);\n            // increment a count given as arg (either no value or value parsed as boolean)\n            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n                value = increment();\n            }\n            // Set normalized value when key is in 'normalize' and in 'arrays'\n            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n                if (Array.isArray(val))\n                    value = val.map((val) => { return mixin.normalize(val); });\n                else\n                    value = mixin.normalize(val);\n            }\n            return value;\n        }\n        function maybeCoerceNumber(key, value) {\n            if (!configuration['parse-positional-numbers'] && key === '_')\n                return value;\n            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));\n                if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) {\n                    value = Number(value);\n                }\n            }\n            return value;\n        }\n        // set args from config.json file, this should be\n        // applied last so that defaults can be applied.\n        function setConfig(argv) {\n            const configLookup = Object.create(null);\n            // expand defaults/aliases, in-case any happen to reference\n            // the config.json file.\n            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n            Object.keys(flags.configs).forEach(function (configKey) {\n                const configPath = argv[configKey] || configLookup[configKey];\n                if (configPath) {\n                    try {\n                        let config = null;\n                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);\n                        const resolveConfig = flags.configs[configKey];\n                        if (typeof resolveConfig === 'function') {\n                            try {\n                                config = resolveConfig(resolvedConfigPath);\n                            }\n                            catch (e) {\n                                config = e;\n                            }\n                            if (config instanceof Error) {\n                                error = config;\n                                return;\n                            }\n                        }\n                        else {\n                            config = mixin.require(resolvedConfigPath);\n                        }\n                        setConfigObject(config);\n                    }\n                    catch (ex) {\n                        // Deno will receive a PermissionDenied error if an attempt is\n                        // made to load config without the --allow-read flag:\n                        if (ex.name === 'PermissionDenied')\n                            error = ex;\n                        else if (argv[configKey])\n                            error = Error(__('Invalid JSON config file: %s', configPath));\n                    }\n                }\n            });\n        }\n        // set args from config object.\n        // it recursively checks nested objects.\n        function setConfigObject(config, prev) {\n            Object.keys(config).forEach(function (key) {\n                const value = config[key];\n                const fullKey = prev ? prev + '.' + key : key;\n                // if the value is an inner object and we have dot-notation\n                // enabled, treat inner objects in config the same as\n                // heavily nested dot notations (foo.bar.apple).\n                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n                    // if the value is an object but not an array, check nested object\n                    setConfigObject(value, fullKey);\n                }\n                else {\n                    // setting arguments via CLI takes precedence over\n                    // values within the config file.\n                    if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {\n                        setArg(fullKey, value);\n                    }\n                }\n            });\n        }\n        // set all config objects passed in opts\n        function setConfigObjects() {\n            if (typeof configObjects !== 'undefined') {\n                configObjects.forEach(function (configObject) {\n                    setConfigObject(configObject);\n                });\n            }\n        }\n        function applyEnvVars(argv, configOnly) {\n            if (typeof envPrefix === 'undefined')\n                return;\n            const prefix = typeof envPrefix === 'string' ? envPrefix : '';\n            const env = mixin.env();\n            Object.keys(env).forEach(function (envVar) {\n                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n                    // get array of nested keys and convert them to camel case\n                    const keys = envVar.split('__').map(function (key, i) {\n                        if (i === 0) {\n                            key = key.substring(prefix.length);\n                        }\n                        return camelCase(key);\n                    });\n                    if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {\n                        setArg(keys.join('.'), env[envVar]);\n                    }\n                }\n            });\n        }\n        function applyCoercions(argv) {\n            let coerce;\n            const applied = new Set();\n            Object.keys(argv).forEach(function (key) {\n                if (!applied.has(key)) { // If we haven't already coerced this option via one of its aliases\n                    coerce = checkAllAliases(key, flags.coercions);\n                    if (typeof coerce === 'function') {\n                        try {\n                            const value = maybeCoerceNumber(key, coerce(argv[key]));\n                            ([].concat(flags.aliases[key] || [], key)).forEach(ali => {\n                                applied.add(ali);\n                                argv[ali] = value;\n                            });\n                        }\n                        catch (err) {\n                            error = err;\n                        }\n                    }\n                }\n            });\n        }\n        function setPlaceholderKeys(argv) {\n            flags.keys.forEach((key) => {\n                // don't set placeholder keys for dot notation options 'foo.bar'.\n                if (~key.indexOf('.'))\n                    return;\n                if (typeof argv[key] === 'undefined')\n                    argv[key] = undefined;\n            });\n            return argv;\n        }\n        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {\n            Object.keys(defaults).forEach(function (key) {\n                if (!hasKey(obj, key.split('.'))) {\n                    setKey(obj, key.split('.'), defaults[key]);\n                    if (canLog)\n                        defaulted[key] = true;\n                    (aliases[key] || []).forEach(function (x) {\n                        if (hasKey(obj, x.split('.')))\n                            return;\n                        setKey(obj, x.split('.'), defaults[key]);\n                    });\n                }\n            });\n        }\n        function hasKey(obj, keys) {\n            let o = obj;\n            if (!configuration['dot-notation'])\n                keys = [keys.join('.')];\n            keys.slice(0, -1).forEach(function (key) {\n                o = (o[key] || {});\n            });\n            const key = keys[keys.length - 1];\n            if (typeof o !== 'object')\n                return false;\n            else\n                return key in o;\n        }\n        function setKey(obj, keys, value) {\n            let o = obj;\n            if (!configuration['dot-notation'])\n                keys = [keys.join('.')];\n            keys.slice(0, -1).forEach(function (key) {\n                // TODO(bcoe): in the next major version of yargs, switch to\n                // Object.create(null) for dot notation:\n                key = sanitizeKey(key);\n                if (typeof o === 'object' && o[key] === undefined) {\n                    o[key] = {};\n                }\n                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n                    // ensure that o[key] is an array, and that the last item is an empty object.\n                    if (Array.isArray(o[key])) {\n                        o[key].push({});\n                    }\n                    else {\n                        o[key] = [o[key], {}];\n                    }\n                    // we want to update the empty object at the end of the o[key] array, so set o to that object\n                    o = o[key][o[key].length - 1];\n                }\n                else {\n                    o = o[key];\n                }\n            });\n            // TODO(bcoe): in the next major version of yargs, switch to\n            // Object.create(null) for dot notation:\n            const key = sanitizeKey(keys[keys.length - 1]);\n            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n            const isValueArray = Array.isArray(value);\n            let duplicate = configuration['duplicate-arguments-array'];\n            // nargs has higher priority than duplicate\n            if (!duplicate && checkAllAliases(key, flags.nargs)) {\n                duplicate = true;\n                if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {\n                    o[key] = undefined;\n                }\n            }\n            if (value === increment()) {\n                o[key] = increment(o[key]);\n            }\n            else if (Array.isArray(o[key])) {\n                if (duplicate && isTypeArray && isValueArray) {\n                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n                }\n                else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n                    o[key] = value;\n                }\n                else {\n                    o[key] = o[key].concat([value]);\n                }\n            }\n            else if (o[key] === undefined && isTypeArray) {\n                o[key] = isValueArray ? value : [value];\n            }\n            else if (duplicate && !(o[key] === undefined ||\n                checkAllAliases(key, flags.counts) ||\n                checkAllAliases(key, flags.bools))) {\n                o[key] = [o[key], value];\n            }\n            else {\n                o[key] = value;\n            }\n        }\n        // extend the aliases list with inferred aliases.\n        function extendAliases(...args) {\n            args.forEach(function (obj) {\n                Object.keys(obj || {}).forEach(function (key) {\n                    // short-circuit if we've already added a key\n                    // to the aliases array, for example it might\n                    // exist in both 'opts.default' and 'opts.key'.\n                    if (flags.aliases[key])\n                        return;\n                    flags.aliases[key] = [].concat(aliases[key] || []);\n                    // For \"--option-name\", also set argv.optionName\n                    flags.aliases[key].concat(key).forEach(function (x) {\n                        if (/-/.test(x) && configuration['camel-case-expansion']) {\n                            const c = camelCase(x);\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    // For \"--optionName\", also set argv['option-name']\n                    flags.aliases[key].concat(key).forEach(function (x) {\n                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n                            const c = decamelize(x, '-');\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    flags.aliases[key].forEach(function (x) {\n                        flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n                            return x !== y;\n                        }));\n                    });\n                });\n            });\n        }\n        function checkAllAliases(key, flag) {\n            const toCheck = [].concat(flags.aliases[key] || [], key);\n            const keys = Object.keys(flag);\n            const setAlias = toCheck.find(key => keys.includes(key));\n            return setAlias ? flag[setAlias] : false;\n        }\n        function hasAnyFlag(key) {\n            const flagsKeys = Object.keys(flags);\n            const toCheck = [].concat(flagsKeys.map(k => flags[k]));\n            return toCheck.some(function (flag) {\n                return Array.isArray(flag) ? flag.includes(key) : flag[key];\n            });\n        }\n        function hasFlagsMatching(arg, ...patterns) {\n            const toCheck = [].concat(...patterns);\n            return toCheck.some(function (pattern) {\n                const match = arg.match(pattern);\n                return match && hasAnyFlag(match[1]);\n            });\n        }\n        // based on a simplified version of the short flag group parsing logic\n        function hasAllShortFlags(arg) {\n            // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n                return false;\n            }\n            let hasAllFlags = true;\n            let next;\n            const letters = arg.slice(1).split('');\n            for (let j = 0; j < letters.length; j++) {\n                next = arg.slice(j + 2);\n                if (!hasAnyFlag(letters[j])) {\n                    hasAllFlags = false;\n                    break;\n                }\n                if ((letters[j + 1] && letters[j + 1] === '=') ||\n                    next === '-' ||\n                    (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) ||\n                    (letters[j + 1] && letters[j + 1].match(/\\W/))) {\n                    break;\n                }\n            }\n            return hasAllFlags;\n        }\n        function isUnknownOptionAsArg(arg) {\n            return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n        }\n        function isUnknownOption(arg) {\n            arg = arg.replace(/^-{3,}/, '--');\n            // ignore negative numbers\n            if (arg.match(negative)) {\n                return false;\n            }\n            // if this is a short option group and all of them are configured, it isn't unknown\n            if (hasAllShortFlags(arg)) {\n                return false;\n            }\n            // e.g. '--count=2'\n            const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/;\n            // e.g. '-a' or '--arg'\n            const normalFlag = /^-+([^=]+?)$/;\n            // e.g. '-a-'\n            const flagEndingInHyphen = /^-+([^=]+?)-$/;\n            // e.g. '-abc123'\n            const flagEndingInDigits = /^-+([^=]+?\\d+)$/;\n            // e.g. '-a/usr/local'\n            const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/;\n            // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n        }\n        // make a best effort to pick a default value\n        // for an option based on name and type.\n        function defaultValue(key) {\n            if (!checkAllAliases(key, flags.bools) &&\n                !checkAllAliases(key, flags.counts) &&\n                `${key}` in defaults) {\n                return defaults[key];\n            }\n            else {\n                return defaultForType(guessType(key));\n            }\n        }\n        // return a default value, given the type of a flag.,\n        function defaultForType(type) {\n            const def = {\n                [DefaultValuesForTypeKey.BOOLEAN]: true,\n                [DefaultValuesForTypeKey.STRING]: '',\n                [DefaultValuesForTypeKey.NUMBER]: undefined,\n                [DefaultValuesForTypeKey.ARRAY]: []\n            };\n            return def[type];\n        }\n        // given a flag, enforce a default type.\n        function guessType(key) {\n            let type = DefaultValuesForTypeKey.BOOLEAN;\n            if (checkAllAliases(key, flags.strings))\n                type = DefaultValuesForTypeKey.STRING;\n            else if (checkAllAliases(key, flags.numbers))\n                type = DefaultValuesForTypeKey.NUMBER;\n            else if (checkAllAliases(key, flags.bools))\n                type = DefaultValuesForTypeKey.BOOLEAN;\n            else if (checkAllAliases(key, flags.arrays))\n                type = DefaultValuesForTypeKey.ARRAY;\n            return type;\n        }\n        function isUndefined(num) {\n            return num === undefined;\n        }\n        // check user configuration settings for inconsistencies\n        function checkConfiguration() {\n            // count keys should not be set as array/narg\n            Object.keys(flags.counts).find(key => {\n                if (checkAllAliases(key, flags.arrays)) {\n                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));\n                    return true;\n                }\n                else if (checkAllAliases(key, flags.nargs)) {\n                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));\n                    return true;\n                }\n                return false;\n            });\n        }\n        return {\n            aliases: Object.assign({}, flags.aliases),\n            argv: Object.assign(argvReturn, argv),\n            configuration: configuration,\n            defaulted: Object.assign({}, defaulted),\n            error: error,\n            newAliases: Object.assign({}, newAliases)\n        };\n    }\n}\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases(aliases) {\n    const aliasArrays = [];\n    const combined = Object.create(null);\n    let change = true;\n    // turn alias lookup hash {key: ['alias1', 'alias2']} into\n    // a simple array ['key', 'alias1', 'alias2']\n    Object.keys(aliases).forEach(function (key) {\n        aliasArrays.push([].concat(aliases[key], key));\n    });\n    // combine arrays until zero changes are\n    // made in an iteration.\n    while (change) {\n        change = false;\n        for (let i = 0; i < aliasArrays.length; i++) {\n            for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n                const intersect = aliasArrays[i].filter(function (v) {\n                    return aliasArrays[ii].indexOf(v) !== -1;\n                });\n                if (intersect.length) {\n                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n                    aliasArrays.splice(ii, 1);\n                    change = true;\n                    break;\n                }\n            }\n        }\n    }\n    // map arrays back to the hash-lookup (de-dupe while\n    // we're at it).\n    aliasArrays.forEach(function (aliasArray) {\n        aliasArray = aliasArray.filter(function (v, i, self) {\n            return self.indexOf(v) === i;\n        });\n        const lastAlias = aliasArray.pop();\n        if (lastAlias !== undefined && typeof lastAlias === 'string') {\n            combined[lastAlias] = aliasArray;\n        }\n    });\n    return combined;\n}\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment(orig) {\n    return orig !== undefined ? orig + 1 : 1;\n}\n// TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\nfunction sanitizeKey(key) {\n    if (key === '__proto__')\n        return '___proto___';\n    return key;\n}\nfunction stripQuotes(val) {\n    return (typeof val === 'string' &&\n        (val[0] === \"'\" || val[0] === '\"') &&\n        val[val.length - 1] === val[0])\n        ? val.substring(1, val.length - 1)\n        : val;\n}\n"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,iBAAT,QAAkC,0BAAlC;AACA,SAASC,uBAAT,QAAwC,yBAAxC;AACA,SAASC,SAAT,EAAoBC,UAApB,EAAgCC,eAAhC,QAAuD,mBAAvD;AACA,IAAIC,KAAJ;AACA,WAAaC,WAAb;EACI,qBAAYC,MAAZ,EAAoB;IAAA;;IAChBF,KAAK,GAAGE,MAAR;EACH;;EAHL;IAAA;IAAA,OAII,eAAMC,SAAN,EAAiBC,OAAjB,EAA0B;MACtB,IAAMC,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc;QACvBC,KAAK,EAAEC,SADgB;QAEvBC,KAAK,EAAED,SAFgB;QAGvBE,OAAO,EAAEF,SAHc;QAIvBG,MAAM,EAAEH,SAJe;QAKvBI,aAAa,EAAEJ,SALQ;QAMvBK,aAAa,EAAEL,SANQ;QAOvBM,MAAM,EAAEN,SAPe;QAQvBO,KAAK,EAAEP,SARgB;QASvBQ,OAAO,EAAER,SATc;QAUvBS,SAAS,EAAET,SAVY;QAWvBU,IAAI,EAAEV,SAXiB;QAYvBW,SAAS,EAAEX,SAZY;QAavBY,MAAM,EAAEZ,SAbe;QAcvBa,MAAM,EAAEb,SAde;QAevBc,EAAE,EAAEd,SAfmB;QAgBvBe,GAAG,EAAEf;MAhBkB,CAAd,EAiBVL,OAjBU,CAAb,CADsB,CAmBtB;MACA;;MACA,IAAMqB,IAAI,GAAG9B,iBAAiB,CAACQ,SAAD,CAA9B,CArBsB,CAsBtB;MACA;;MACA,IAAMuB,aAAa,GAAG,OAAOvB,SAAP,KAAqB,QAA3C,CAxBsB,CAyBtB;;MACA,IAAMwB,OAAO,GAAGC,cAAc,CAACtB,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACuB,MAAP,CAAc,IAAd,CAAd,EAAmCxB,IAAI,CAACG,KAAxC,CAAD,CAA9B;MACA,IAAMM,aAAa,GAAGR,MAAM,CAACC,MAAP,CAAc;QAChC,oBAAoB,IADY;QAEhC,wBAAwB,IAFQ;QAGhC,kBAAkB,KAHc;QAIhC,gBAAgB,IAJgB;QAKhC,6BAA6B,IALG;QAMhC,4BAA4B,IANI;QAOhC,iBAAiB,IAPe;QAQhC,sBAAsB,KARU;QAShC,sBAAsB,KATU;QAUhC,mBAAmB,KAVa;QAWhC,iBAAiB,IAXe;QAYhC,4BAA4B,IAZI;QAahC,cAAc,KAbkB;QAchC,uBAAuB,KAdS;QAehC,uBAAuB,IAfS;QAgBhC,iBAAiB,KAhBe;QAiBhC,gBAAgB,KAjBgB;QAkBhC,2BAA2B;MAlBK,CAAd,EAmBnBF,IAAI,CAACS,aAnBc,CAAtB;MAoBA,IAAMgB,QAAQ,GAAGxB,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACuB,MAAP,CAAc,IAAd,CAAd,EAAmCxB,IAAI,CAACY,OAAxC,CAAjB;MACA,IAAMJ,aAAa,GAAGR,IAAI,CAACQ,aAAL,IAAsB,EAA5C;MACA,IAAMK,SAAS,GAAGb,IAAI,CAACa,SAAvB;MACA,IAAMa,cAAc,GAAGjB,aAAa,CAAC,YAAD,CAApC;MACA,IAAMkB,YAAY,GAAGD,cAAc,GAAG,IAAH,GAAU,GAA7C;MACA,IAAME,UAAU,GAAG3B,MAAM,CAACuB,MAAP,CAAc,IAAd,CAAnB;MACA,IAAMK,SAAS,GAAG5B,MAAM,CAACuB,MAAP,CAAc,IAAd,CAAlB,CArDsB,CAsDtB;;MACA,IAAMN,EAAE,GAAGlB,IAAI,CAACkB,EAAL,IAAWvB,KAAK,CAACmC,MAA5B;;MACA,IAAMC,KAAK,GAAG;QACVT,OAAO,EAAErB,MAAM,CAACuB,MAAP,CAAc,IAAd,CADC;QAEVQ,MAAM,EAAE/B,MAAM,CAACuB,MAAP,CAAc,IAAd,CAFE;QAGVS,KAAK,EAAEhC,MAAM,CAACuB,MAAP,CAAc,IAAd,CAHG;QAIVU,OAAO,EAAEjC,MAAM,CAACuB,MAAP,CAAc,IAAd,CAJC;QAKVW,OAAO,EAAElC,MAAM,CAACuB,MAAP,CAAc,IAAd,CALC;QAMVY,MAAM,EAAEnC,MAAM,CAACuB,MAAP,CAAc,IAAd,CANE;QAOVT,SAAS,EAAEd,MAAM,CAACuB,MAAP,CAAc,IAAd,CAPD;QAQVa,OAAO,EAAEpC,MAAM,CAACuB,MAAP,CAAc,IAAd,CARC;QASVc,KAAK,EAAErC,MAAM,CAACuB,MAAP,CAAc,IAAd,CATG;QAUVe,SAAS,EAAEtC,MAAM,CAACuB,MAAP,CAAc,IAAd,CAVD;QAWVgB,IAAI,EAAE;MAXI,CAAd;MAaA,IAAMC,QAAQ,GAAG,iCAAjB;MACA,IAAMC,cAAc,GAAG,IAAIC,MAAJ,CAAW,QAAQlC,aAAa,CAAC,iBAAD,CAArB,GAA2C,MAAtD,CAAvB;MACA,GAAGmC,MAAH,CAAU5C,IAAI,CAACK,KAAL,IAAc,EAAxB,EAA4BwC,MAA5B,CAAmCC,OAAnC,EAA4CC,OAA5C,CAAoD,UAAUC,GAAV,EAAe;QAC/D,IAAM7B,GAAG,GAAG,OAAO6B,GAAP,KAAe,QAAf,GAA0BA,GAAG,CAAC7B,GAA9B,GAAoC6B,GAAhD,CAD+D,CAE/D;;QACA,IAAMC,UAAU,GAAGhD,MAAM,CAACuC,IAAP,CAAYQ,GAAZ,EAAiBE,GAAjB,CAAqB,UAAU/B,GAAV,EAAe;UACnD,IAAMgC,aAAa,GAAG;YAClB7C,OAAO,EAAE,OADS;YAElBU,MAAM,EAAE,SAFU;YAGlBC,MAAM,EAAE;UAHU,CAAtB;UAKA,OAAOkC,aAAa,CAAChC,GAAD,CAApB;QACH,CAPkB,EAOhB0B,MAPgB,CAOTC,OAPS,EAOAM,GAPA,EAAnB,CAH+D,CAW/D;;QACA,IAAIH,UAAJ,EAAgB;UACZlB,KAAK,CAACkB,UAAD,CAAL,CAAkB9B,GAAlB,IAAyB,IAAzB;QACH;;QACDY,KAAK,CAACC,MAAN,CAAab,GAAb,IAAoB,IAApB;QACAY,KAAK,CAACS,IAAN,CAAWa,IAAX,CAAgBlC,GAAhB;MACH,CAjBD;MAkBA,GAAGyB,MAAH,CAAU5C,IAAI,CAACM,OAAL,IAAgB,EAA1B,EAA8BuC,MAA9B,CAAqCC,OAArC,EAA8CC,OAA9C,CAAsD,UAAU5B,GAAV,EAAe;QACjEY,KAAK,CAACE,KAAN,CAAYd,GAAZ,IAAmB,IAAnB;QACAY,KAAK,CAACS,IAAN,CAAWa,IAAX,CAAgBlC,GAAhB;MACH,CAHD;MAIA,GAAGyB,MAAH,CAAU5C,IAAI,CAACgB,MAAL,IAAe,EAAzB,EAA6B6B,MAA7B,CAAoCC,OAApC,EAA6CC,OAA7C,CAAqD,UAAU5B,GAAV,EAAe;QAChEY,KAAK,CAACG,OAAN,CAAcf,GAAd,IAAqB,IAArB;QACAY,KAAK,CAACS,IAAN,CAAWa,IAAX,CAAgBlC,GAAhB;MACH,CAHD;MAIA,GAAGyB,MAAH,CAAU5C,IAAI,CAACiB,MAAL,IAAe,EAAzB,EAA6B4B,MAA7B,CAAoCC,OAApC,EAA6CC,OAA7C,CAAqD,UAAU5B,GAAV,EAAe;QAChEY,KAAK,CAACI,OAAN,CAAchB,GAAd,IAAqB,IAArB;QACAY,KAAK,CAACS,IAAN,CAAWa,IAAX,CAAgBlC,GAAhB;MACH,CAHD;MAIA,GAAGyB,MAAH,CAAU5C,IAAI,CAACW,KAAL,IAAc,EAAxB,EAA4BkC,MAA5B,CAAmCC,OAAnC,EAA4CC,OAA5C,CAAoD,UAAU5B,GAAV,EAAe;QAC/DY,KAAK,CAACK,MAAN,CAAajB,GAAb,IAAoB,IAApB;QACAY,KAAK,CAACS,IAAN,CAAWa,IAAX,CAAgBlC,GAAhB;MACH,CAHD;MAIA,GAAGyB,MAAH,CAAU5C,IAAI,CAACe,SAAL,IAAkB,EAA5B,EAAgC8B,MAAhC,CAAuCC,OAAvC,EAAgDC,OAAhD,CAAwD,UAAU5B,GAAV,EAAe;QACnEY,KAAK,CAAChB,SAAN,CAAgBI,GAAhB,IAAuB,IAAvB;QACAY,KAAK,CAACS,IAAN,CAAWa,IAAX,CAAgBlC,GAAhB;MACH,CAHD;;MAIA,IAAI,OAAOnB,IAAI,CAACc,IAAZ,KAAqB,QAAzB,EAAmC;QAC/Bb,MAAM,CAACqD,OAAP,CAAetD,IAAI,CAACc,IAApB,EAA0BiC,OAA1B,CAAkC,gBAAkB;UAAA;UAAA,IAAhB5B,GAAgB;UAAA,IAAXoC,KAAW;;UAChD,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;YAC3BxB,KAAK,CAACO,KAAN,CAAYnB,GAAZ,IAAmBoC,KAAnB;YACAxB,KAAK,CAACS,IAAN,CAAWa,IAAX,CAAgBlC,GAAhB;UACH;QACJ,CALD;MAMH;;MACD,IAAI,OAAOnB,IAAI,CAACU,MAAZ,KAAuB,QAA3B,EAAqC;QACjCT,MAAM,CAACqD,OAAP,CAAetD,IAAI,CAACU,MAApB,EAA4BqC,OAA5B,CAAoC,iBAAkB;UAAA;UAAA,IAAhB5B,GAAgB;UAAA,IAAXoC,KAAW;;UAClD,IAAI,OAAOA,KAAP,KAAiB,UAArB,EAAiC;YAC7BxB,KAAK,CAACQ,SAAN,CAAgBpB,GAAhB,IAAuBoC,KAAvB;YACAxB,KAAK,CAACS,IAAN,CAAWa,IAAX,CAAgBlC,GAAhB;UACH;QACJ,CALD;MAMH;;MACD,IAAI,OAAOnB,IAAI,CAACO,MAAZ,KAAuB,WAA3B,EAAwC;QACpC,IAAIiD,KAAK,CAACC,OAAN,CAAczD,IAAI,CAACO,MAAnB,KAA8B,OAAOP,IAAI,CAACO,MAAZ,KAAuB,QAAzD,EAAmE;UAC/D;UACA,GAAGqC,MAAH,CAAU5C,IAAI,CAACO,MAAf,EAAuBsC,MAAvB,CAA8BC,OAA9B,EAAuCC,OAAvC,CAA+C,UAAU5B,GAAV,EAAe;YAC1DY,KAAK,CAACM,OAAN,CAAclB,GAAd,IAAqB,IAArB;UACH,CAFD;QAGH,CALD,MAMK,IAAI,OAAOnB,IAAI,CAACO,MAAZ,KAAuB,QAA3B,EAAqC;UACtCN,MAAM,CAACqD,OAAP,CAAetD,IAAI,CAACO,MAApB,EAA4BwC,OAA5B,CAAoC,iBAAkB;YAAA;YAAA,IAAhB5B,GAAgB;YAAA,IAAXoC,KAAW;;YAClD,IAAI,OAAOA,KAAP,KAAiB,SAAjB,IAA8B,OAAOA,KAAP,KAAiB,UAAnD,EAA+D;cAC3DxB,KAAK,CAACM,OAAN,CAAclB,GAAd,IAAqBoC,KAArB;YACH;UACJ,CAJD;QAKH;MACJ,CA3IqB,CA4ItB;MACA;;;MACAG,aAAa,CAAC1D,IAAI,CAACmB,GAAN,EAAWG,OAAX,EAAoBtB,IAAI,CAACY,OAAzB,EAAkCmB,KAAK,CAACC,MAAxC,CAAb,CA9IsB,CA+ItB;;MACA/B,MAAM,CAACuC,IAAP,CAAYf,QAAZ,EAAsBsB,OAAtB,CAA8B,UAAU5B,GAAV,EAAe;QACzC,CAACY,KAAK,CAACT,OAAN,CAAcH,GAAd,KAAsB,EAAvB,EAA2B4B,OAA3B,CAAmC,UAAU5C,KAAV,EAAiB;UAChDsB,QAAQ,CAACtB,KAAD,CAAR,GAAkBsB,QAAQ,CAACN,GAAD,CAA1B;QACH,CAFD;MAGH,CAJD;MAKA,IAAIwC,KAAK,GAAG,IAAZ;MACAC,kBAAkB;MAClB,IAAIC,QAAQ,GAAG,EAAf;MACA,IAAMC,IAAI,GAAG7D,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACuB,MAAP,CAAc,IAAd,CAAd,EAAmC;QAAEuC,CAAC,EAAE;MAAL,CAAnC,CAAb,CAxJsB,CAyJtB;MACA;MACA;;MACA,IAAMC,UAAU,GAAG,EAAnB;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7C,IAAI,CAAC8C,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;QAClC,IAAME,GAAG,GAAG/C,IAAI,CAAC6C,CAAD,CAAhB;QACA,IAAMG,YAAY,GAAGD,GAAG,CAACE,OAAJ,CAAY,QAAZ,EAAsB,KAAtB,CAArB;QACA,IAAIC,MAAM,SAAV;QACA,IAAInD,GAAG,SAAP;QACA,IAAIoD,OAAO,SAAX;QACA,IAAIC,CAAC,SAAL;QACA,IAAIC,IAAI,SAAR;QACA,IAAIlB,KAAK,SAAT,CARkC,CASlC;;QACA,IAAIY,GAAG,KAAK,IAAR,IAAgBO,oBAAoB,CAACP,GAAD,CAAxC,EAA+C;UAC3CQ,cAAc,CAACR,GAAD,CAAd,CAD2C,CAE3C;QACH,CAHD,MAIK,IAAIC,YAAY,CAACQ,KAAb,CAAmB,WAAnB,CAAJ,EAAqC;UACtC;UACAD,cAAc,CAACR,GAAD,CAAd;UACA,SAHsC,CAItC;QACH,CALI,MAMA,IAAIA,GAAG,CAACS,KAAJ,CAAU,QAAV,KAAwB,CAACnE,aAAa,CAAC,qBAAD,CAAd,IAAyC0D,GAAG,CAACS,KAAJ,CAAU,OAAV,CAArE,EAA0F;UAC3F;UACA;UACA;UACAJ,CAAC,GAAGL,GAAG,CAACS,KAAJ,CAAU,wBAAV,CAAJ,CAJ2F,CAK3F;;UACA,IAAIJ,CAAC,KAAK,IAAN,IAAchB,KAAK,CAACC,OAAN,CAAce,CAAd,CAAd,IAAkCA,CAAC,CAACN,MAAF,IAAY,CAAlD,EAAqD;YACjD,IAAIW,eAAe,CAACL,CAAC,CAAC,CAAD,CAAF,EAAOzC,KAAK,CAACC,MAAb,CAAnB,EAAyC;cACrCiC,CAAC,GAAGa,QAAQ,CAACb,CAAD,EAAIO,CAAC,CAAC,CAAD,CAAL,EAAUpD,IAAV,EAAgBoD,CAAC,CAAC,CAAD,CAAjB,CAAZ;YACH,CAFD,MAGK,IAAIK,eAAe,CAACL,CAAC,CAAC,CAAD,CAAF,EAAOzC,KAAK,CAACO,KAAb,CAAf,KAAuC,KAA3C,EAAkD;cACnD;cACA2B,CAAC,GAAGc,QAAQ,CAACd,CAAD,EAAIO,CAAC,CAAC,CAAD,CAAL,EAAUpD,IAAV,EAAgBoD,CAAC,CAAC,CAAD,CAAjB,CAAZ;YACH,CAHI,MAIA;cACDQ,MAAM,CAACR,CAAC,CAAC,CAAD,CAAF,EAAOA,CAAC,CAAC,CAAD,CAAR,EAAa,IAAb,CAAN;YACH;UACJ;QACJ,CAlBI,MAmBA,IAAIL,GAAG,CAACS,KAAJ,CAAUlC,cAAV,KAA6BjC,aAAa,CAAC,kBAAD,CAA9C,EAAoE;UACrE+D,CAAC,GAAGL,GAAG,CAACS,KAAJ,CAAUlC,cAAV,CAAJ;;UACA,IAAI8B,CAAC,KAAK,IAAN,IAAchB,KAAK,CAACC,OAAN,CAAce,CAAd,CAAd,IAAkCA,CAAC,CAACN,MAAF,IAAY,CAAlD,EAAqD;YACjD/C,GAAG,GAAGqD,CAAC,CAAC,CAAD,CAAP;YACAQ,MAAM,CAAC7D,GAAD,EAAM0D,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACC,MAAZ,CAAf,GAAqC,CAAC,KAAD,CAArC,GAA+C,KAArD,CAAN;UACH,CALoE,CAMrE;;QACH,CAPI,MAQA,IAAImC,GAAG,CAACS,KAAJ,CAAU,OAAV,KAAuB,CAACnE,aAAa,CAAC,qBAAD,CAAd,IAAyC0D,GAAG,CAACS,KAAJ,CAAU,SAAV,CAApE,EAA2F;UAC5FJ,CAAC,GAAGL,GAAG,CAACS,KAAJ,CAAU,UAAV,CAAJ;;UACA,IAAIJ,CAAC,KAAK,IAAN,IAAchB,KAAK,CAACC,OAAN,CAAce,CAAd,CAAd,IAAkCA,CAAC,CAACN,MAAF,IAAY,CAAlD,EAAqD;YACjD/C,GAAG,GAAGqD,CAAC,CAAC,CAAD,CAAP;;YACA,IAAIK,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACC,MAAZ,CAAnB,EAAwC;cACpC;cACAiC,CAAC,GAAGa,QAAQ,CAACb,CAAD,EAAI9C,GAAJ,EAASC,IAAT,CAAZ;YACH,CAHD,MAIK,IAAIyD,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACO,KAAZ,CAAf,KAAsC,KAA1C,EAAiD;cAClD;cACA;cACA2B,CAAC,GAAGc,QAAQ,CAACd,CAAD,EAAI9C,GAAJ,EAASC,IAAT,CAAZ;YACH,CAJI,MAKA;cACDqD,IAAI,GAAGrD,IAAI,CAAC6C,CAAC,GAAG,CAAL,CAAX;;cACA,IAAIQ,IAAI,KAAKrE,SAAT,KAAuB,CAACqE,IAAI,CAACG,KAAL,CAAW,IAAX,CAAD,IACvBH,IAAI,CAACG,KAAL,CAAWnC,QAAX,CADA,KAEA,CAACoC,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACE,KAAZ,CAFhB,IAGA,CAAC4C,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACK,MAAZ,CAHpB,EAGyC;gBACrC4C,MAAM,CAAC7D,GAAD,EAAMsD,IAAN,CAAN;gBACAR,CAAC;cACJ,CAND,MAOK,IAAI,iBAAiBgB,IAAjB,CAAsBR,IAAtB,CAAJ,EAAiC;gBAClCO,MAAM,CAAC7D,GAAD,EAAMsD,IAAN,CAAN;gBACAR,CAAC;cACJ,CAHI,MAIA;gBACDe,MAAM,CAAC7D,GAAD,EAAM+D,YAAY,CAAC/D,GAAD,CAAlB,CAAN;cACH;YACJ;UACJ,CA9B2F,CA+B5F;;QACH,CAhCI,MAiCA,IAAIgD,GAAG,CAACS,KAAJ,CAAU,UAAV,CAAJ,EAA2B;UAC5BJ,CAAC,GAAGL,GAAG,CAACS,KAAJ,CAAU,sBAAV,CAAJ;;UACA,IAAIJ,CAAC,KAAK,IAAN,IAAchB,KAAK,CAACC,OAAN,CAAce,CAAd,CAAd,IAAkCA,CAAC,CAACN,MAAF,IAAY,CAAlD,EAAqD;YACjDc,MAAM,CAACR,CAAC,CAAC,CAAD,CAAF,EAAOA,CAAC,CAAC,CAAD,CAAR,CAAN;UACH,CAJ2B,CAK5B;;QACH,CANI,MAOA,IAAIL,GAAG,CAACS,KAAJ,CAAU,SAAV,KAAwB,CAACT,GAAG,CAACS,KAAJ,CAAUnC,QAAV,CAA7B,EAAkD;UACnDgC,IAAI,GAAGrD,IAAI,CAAC6C,CAAC,GAAG,CAAL,CAAX;UACAO,CAAC,GAAGL,GAAG,CAACS,KAAJ,CAAU,WAAV,CAAJ;;UACA,IAAIJ,CAAC,KAAK,IAAN,IAAchB,KAAK,CAACC,OAAN,CAAce,CAAd,CAAd,IAAkCA,CAAC,CAACN,MAAF,IAAY,CAAlD,EAAqD;YACjD/C,GAAG,GAAGqD,CAAC,CAAC,CAAD,CAAP;;YACA,IAAIC,IAAI,KAAKrE,SAAT,IAAsB,CAACqE,IAAI,CAACG,KAAL,CAAW,IAAX,CAAvB,IACA,CAACC,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACE,KAAZ,CADhB,IAEA,CAAC4C,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACK,MAAZ,CAFpB,EAEyC;cACrC4C,MAAM,CAAC7D,GAAD,EAAMsD,IAAN,CAAN;cACAR,CAAC;YACJ,CALD,MAMK;cACDe,MAAM,CAAC7D,GAAD,EAAM+D,YAAY,CAAC/D,GAAD,CAAlB,CAAN;YACH;UACJ;QACJ,CAfI,MAgBA,IAAIgD,GAAG,CAACS,KAAJ,CAAU,SAAV,KAAwB,CAACT,GAAG,CAACS,KAAJ,CAAUnC,QAAV,CAA7B,EAAkD;UACnD8B,OAAO,GAAGJ,GAAG,CAACgB,KAAJ,CAAU,CAAV,EAAa,CAAC,CAAd,EAAiBC,KAAjB,CAAuB,EAAvB,CAAV;UACAd,MAAM,GAAG,KAAT;;UACA,KAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,OAAO,CAACL,MAA5B,EAAoCmB,CAAC,EAArC,EAAyC;YACrCZ,IAAI,GAAGN,GAAG,CAACgB,KAAJ,CAAUE,CAAC,GAAG,CAAd,CAAP;;YACA,IAAId,OAAO,CAACc,CAAC,GAAG,CAAL,CAAP,IAAkBd,OAAO,CAACc,CAAC,GAAG,CAAL,CAAP,KAAmB,GAAzC,EAA8C;cAC1C9B,KAAK,GAAGY,GAAG,CAACgB,KAAJ,CAAUE,CAAC,GAAG,CAAd,CAAR;cACAlE,GAAG,GAAGoD,OAAO,CAACc,CAAD,CAAb;;cACA,IAAIR,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACC,MAAZ,CAAnB,EAAwC;gBACpC;gBACAiC,CAAC,GAAGa,QAAQ,CAACb,CAAD,EAAI9C,GAAJ,EAASC,IAAT,EAAemC,KAAf,CAAZ;cACH,CAHD,MAIK,IAAIsB,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACO,KAAZ,CAAf,KAAsC,KAA1C,EAAiD;gBAClD;gBACA2B,CAAC,GAAGc,QAAQ,CAACd,CAAD,EAAI9C,GAAJ,EAASC,IAAT,EAAemC,KAAf,CAAZ;cACH,CAHI,MAIA;gBACDyB,MAAM,CAAC7D,GAAD,EAAMoC,KAAN,CAAN;cACH;;cACDe,MAAM,GAAG,IAAT;cACA;YACH;;YACD,IAAIG,IAAI,KAAK,GAAb,EAAkB;cACdO,MAAM,CAACT,OAAO,CAACc,CAAD,CAAR,EAAaZ,IAAb,CAAN;cACA;YACH,CAtBoC,CAuBrC;;;YACA,IAAI,WAAWQ,IAAX,CAAgBV,OAAO,CAACc,CAAD,CAAvB,KACA,2BAA2BJ,IAA3B,CAAgCR,IAAhC,CADA,IAEAI,eAAe,CAACJ,IAAD,EAAO1C,KAAK,CAACE,KAAb,CAAf,KAAuC,KAF3C,EAEkD;cAC9C+C,MAAM,CAACT,OAAO,CAACc,CAAD,CAAR,EAAaZ,IAAb,CAAN;cACAH,MAAM,GAAG,IAAT;cACA;YACH;;YACD,IAAIC,OAAO,CAACc,CAAC,GAAG,CAAL,CAAP,IAAkBd,OAAO,CAACc,CAAC,GAAG,CAAL,CAAP,CAAeT,KAAf,CAAqB,IAArB,CAAtB,EAAkD;cAC9CI,MAAM,CAACT,OAAO,CAACc,CAAD,CAAR,EAAaZ,IAAb,CAAN;cACAH,MAAM,GAAG,IAAT;cACA;YACH,CAJD,MAKK;cACDU,MAAM,CAACT,OAAO,CAACc,CAAD,CAAR,EAAaH,YAAY,CAACX,OAAO,CAACc,CAAD,CAAR,CAAzB,CAAN;YACH;UACJ;;UACDlE,GAAG,GAAGgD,GAAG,CAACgB,KAAJ,CAAU,CAAC,CAAX,EAAc,CAAd,CAAN;;UACA,IAAI,CAACb,MAAD,IAAWnD,GAAG,KAAK,GAAvB,EAA4B;YACxB,IAAI0D,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACC,MAAZ,CAAnB,EAAwC;cACpC;cACAiC,CAAC,GAAGa,QAAQ,CAACb,CAAD,EAAI9C,GAAJ,EAASC,IAAT,CAAZ;YACH,CAHD,MAIK,IAAIyD,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACO,KAAZ,CAAf,KAAsC,KAA1C,EAAiD;cAClD;cACA;cACA2B,CAAC,GAAGc,QAAQ,CAACd,CAAD,EAAI9C,GAAJ,EAASC,IAAT,CAAZ;YACH,CAJI,MAKA;cACDqD,IAAI,GAAGrD,IAAI,CAAC6C,CAAC,GAAG,CAAL,CAAX;;cACA,IAAIQ,IAAI,KAAKrE,SAAT,KAAuB,CAAC,cAAc6E,IAAd,CAAmBR,IAAnB,CAAD,IACvBA,IAAI,CAACG,KAAL,CAAWnC,QAAX,CADA,KAEA,CAACoC,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACE,KAAZ,CAFhB,IAGA,CAAC4C,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACK,MAAZ,CAHpB,EAGyC;gBACrC4C,MAAM,CAAC7D,GAAD,EAAMsD,IAAN,CAAN;gBACAR,CAAC;cACJ,CAND,MAOK,IAAI,iBAAiBgB,IAAjB,CAAsBR,IAAtB,CAAJ,EAAiC;gBAClCO,MAAM,CAAC7D,GAAD,EAAMsD,IAAN,CAAN;gBACAR,CAAC;cACJ,CAHI,MAIA;gBACDe,MAAM,CAAC7D,GAAD,EAAM+D,YAAY,CAAC/D,GAAD,CAAlB,CAAN;cACH;YACJ;UACJ;QACJ,CAxEI,MAyEA,IAAIgD,GAAG,CAACS,KAAJ,CAAU,UAAV,KACLT,GAAG,CAACS,KAAJ,CAAUnC,QAAV,CADK,IAELoC,eAAe,CAACV,GAAG,CAACgB,KAAJ,CAAU,CAAV,CAAD,EAAepD,KAAK,CAACE,KAArB,CAFd,EAE2C;UAC5C;UACAd,GAAG,GAAGgD,GAAG,CAACgB,KAAJ,CAAU,CAAV,CAAN;UACAH,MAAM,CAAC7D,GAAD,EAAM+D,YAAY,CAAC/D,GAAD,CAAlB,CAAN;QACH,CANI,MAOA,IAAIgD,GAAG,KAAK,IAAZ,EAAkB;UACnBN,QAAQ,GAAGzC,IAAI,CAAC+D,KAAL,CAAWlB,CAAC,GAAG,CAAf,CAAX;UACA;QACH,CAHI,MAIA,IAAIxD,aAAa,CAAC,oBAAD,CAAjB,EAAyC;UAC1CoD,QAAQ,GAAGzC,IAAI,CAAC+D,KAAL,CAAWlB,CAAX,CAAX;UACA;QACH,CAHI,MAIA;UACDU,cAAc,CAACR,GAAD,CAAd;QACH;MACJ,CA/VqB,CAgWtB;MACA;MACA;MACA;MACA;MACA;;;MACAmB,YAAY,CAACxB,IAAD,EAAO,IAAP,CAAZ,CAtWsB,CAsWI;;MAC1BwB,YAAY,CAACxB,IAAD,EAAO,KAAP,CAAZ;MACAyB,SAAS,CAACzB,IAAD,CAAT;MACA0B,gBAAgB;MAChBC,uBAAuB,CAAC3B,IAAD,EAAO/B,KAAK,CAACT,OAAb,EAAsBG,QAAtB,EAAgC,IAAhC,CAAvB;MACAiE,cAAc,CAAC5B,IAAD,CAAd;MACA,IAAIrD,aAAa,CAAC,qBAAD,CAAjB,EACIkF,kBAAkB,CAAC7B,IAAD,CAAlB,CA7WkB,CA8WtB;;MACA7D,MAAM,CAACuC,IAAP,CAAYT,KAAK,CAACK,MAAlB,EAA0BW,OAA1B,CAAkC,UAAU5B,GAAV,EAAe;QAC7C,IAAI,CAACyE,MAAM,CAAC9B,IAAD,EAAO3C,GAAG,CAACiE,KAAJ,CAAU,GAAV,CAAP,CAAX,EACIJ,MAAM,CAAC7D,GAAD,EAAM,CAAN,CAAN;MACP,CAHD,EA/WsB,CAmXtB;;MACA,IAAIO,cAAc,IAAImC,QAAQ,CAACK,MAA/B,EACIJ,IAAI,CAACnC,YAAD,CAAJ,GAAqB,EAArB;MACJkC,QAAQ,CAACd,OAAT,CAAiB,UAAU5B,GAAV,EAAe;QAC5B2C,IAAI,CAACnC,YAAD,CAAJ,CAAmB0B,IAAnB,CAAwBlC,GAAxB;MACH,CAFD;;MAGA,IAAIV,aAAa,CAAC,sBAAD,CAAb,IAAyCA,aAAa,CAAC,cAAD,CAA1D,EAA4E;QACxER,MAAM,CAACuC,IAAP,CAAYsB,IAAZ,EAAkBjB,MAAlB,CAAyB,UAAA1B,GAAG;UAAA,OAAIA,GAAG,KAAK,IAAR,IAAgBA,GAAG,CAAC0E,QAAJ,CAAa,GAAb,CAApB;QAAA,CAA5B,EAAmE9C,OAAnE,CAA2E,UAAA5B,GAAG,EAAI;UAC9E,OAAO2C,IAAI,CAAC3C,GAAD,CAAX;QACH,CAFD;MAGH;;MACD,IAAIV,aAAa,CAAC,eAAD,CAAjB,EAAoC;QAAA;;QAChC;;QACA,aAAGmC,MAAH,iCAAa3C,MAAM,CAACuC,IAAP,CAAYlB,OAAZ,EAAqB4B,GAArB,CAAyB,UAAA4C,CAAC;UAAA,OAAIxE,OAAO,CAACwE,CAAD,CAAX;QAAA,CAA1B,CAAb,GAAwD/C,OAAxD,CAAgE,UAAA5C,KAAK,EAAI;UACrE,IAAIM,aAAa,CAAC,sBAAD,CAAb,IAAyCN,KAAK,CAAC0F,QAAN,CAAe,GAAf,CAA7C,EAAkE;YAC9D,OAAO/B,IAAI,CAAC3D,KAAK,CAACiF,KAAN,CAAY,GAAZ,EAAiBlC,GAAjB,CAAqB,UAAA6C,IAAI;cAAA,OAAIvG,SAAS,CAACuG,IAAD,CAAb;YAAA,CAAzB,EAA8CC,IAA9C,CAAmD,GAAnD,CAAD,CAAX;UACH;;UACD,OAAOlC,IAAI,CAAC3D,KAAD,CAAX;QACH,CALD;MAMH,CAtYqB,CAuYtB;;;MACA,SAASwE,cAAT,CAAwBR,GAAxB,EAA6B;QACzB,IAAM8B,kBAAkB,GAAGC,iBAAiB,CAAC,GAAD,EAAM/B,GAAN,CAA5C;;QACA,IAAI,OAAO8B,kBAAP,KAA8B,QAA9B,IAA0C,OAAOA,kBAAP,KAA8B,QAA5E,EAAsF;UAClFnC,IAAI,CAACC,CAAL,CAAOV,IAAP,CAAY4C,kBAAZ;QACH;MACJ,CA7YqB,CA8YtB;MACA;;;MACA,SAASlB,QAAT,CAAkBd,CAAlB,EAAqB9C,GAArB,EAA0BC,IAA1B,EAAgC+E,iBAAhC,EAAmD;QAC/C,IAAIC,EAAJ;QACA,IAAIC,KAAK,GAAGxB,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACO,KAAZ,CAA3B,CAF+C,CAG/C;QACA;;QACA+D,KAAK,GAAG,OAAOA,KAAP,KAAiB,QAAjB,IAA6BC,KAAK,CAACD,KAAD,CAAlC,GAA4C,CAA5C,GAAgDA,KAAxD;;QACA,IAAIA,KAAK,KAAK,CAAd,EAAiB;UACb,IAAI,CAACE,WAAW,CAACJ,iBAAD,CAAhB,EAAqC;YACjCxC,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,6BAAD,EAAgCC,GAAhC,CAAH,CAAb;UACH;;UACD6D,MAAM,CAAC7D,GAAD,EAAM+D,YAAY,CAAC/D,GAAD,CAAlB,CAAN;UACA,OAAO8C,CAAP;QACH;;QACD,IAAIwC,SAAS,GAAGF,WAAW,CAACJ,iBAAD,CAAX,GAAiC,CAAjC,GAAqC,CAArD;;QACA,IAAI1F,aAAa,CAAC,oBAAD,CAAjB,EAAyC;UACrC;UACA,IAAIW,IAAI,CAAC8C,MAAL,IAAeD,CAAC,GAAG,CAAnB,IAAwBwC,SAAxB,GAAoCJ,KAAxC,EAA+C;YAC3C1C,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,oCAAD,EAAuCC,GAAvC,CAAH,CAAb;UACH;;UACDsF,SAAS,GAAGJ,KAAZ;QACH,CAND,MAOK;UACD;UACA;UACA,KAAKD,EAAE,GAAGnC,CAAC,GAAG,CAAd,EAAiBmC,EAAE,GAAGhF,IAAI,CAAC8C,MAA3B,EAAmCkC,EAAE,EAArC,EAAyC;YACrC,IAAI,CAAChF,IAAI,CAACgF,EAAD,CAAJ,CAASxB,KAAT,CAAe,UAAf,CAAD,IAA+BxD,IAAI,CAACgF,EAAD,CAAJ,CAASxB,KAAT,CAAenC,QAAf,CAA/B,IAA2DiC,oBAAoB,CAACtD,IAAI,CAACgF,EAAD,CAAL,CAAnF,EACIK,SAAS,GADb,KAGI;UACP;;UACD,IAAIA,SAAS,GAAGJ,KAAhB,EACI1C,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,oCAAD,EAAuCC,GAAvC,CAAH,CAAb;QACP;;QACD,IAAIuF,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAASH,SAAT,EAAoBJ,KAApB,CAAf;;QACA,IAAI,CAACE,WAAW,CAACJ,iBAAD,CAAZ,IAAmCO,QAAQ,GAAG,CAAlD,EAAqD;UACjD1B,MAAM,CAAC7D,GAAD,EAAMgF,iBAAN,CAAN;UACAO,QAAQ;QACX;;QACD,KAAKN,EAAE,GAAGnC,CAAC,GAAG,CAAd,EAAiBmC,EAAE,GAAIM,QAAQ,GAAGzC,CAAX,GAAe,CAAtC,EAA0CmC,EAAE,EAA5C,EAAgD;UAC5CpB,MAAM,CAAC7D,GAAD,EAAMC,IAAI,CAACgF,EAAD,CAAV,CAAN;QACH;;QACD,OAAQnC,CAAC,GAAGyC,QAAZ;MACH,CA1bqB,CA2btB;MACA;MACA;;;MACA,SAAS5B,QAAT,CAAkBb,CAAlB,EAAqB9C,GAArB,EAA0BC,IAA1B,EAAgC+E,iBAAhC,EAAmD;QAC/C,IAAIU,SAAS,GAAG,EAAhB;QACA,IAAIpC,IAAI,GAAG0B,iBAAiB,IAAI/E,IAAI,CAAC6C,CAAC,GAAG,CAAL,CAApC,CAF+C,CAG/C;;QACA,IAAM6C,UAAU,GAAGjC,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACO,KAAZ,CAAlC;;QACA,IAAIuC,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACE,KAAZ,CAAf,IAAqC,CAAE,iBAAiBgD,IAAjB,CAAsBR,IAAtB,CAA3C,EAAyE;UACrEoC,SAAS,CAACxD,IAAV,CAAe,IAAf;QACH,CAFD,MAGK,IAAIkD,WAAW,CAAC9B,IAAD,CAAX,IACJ8B,WAAW,CAACJ,iBAAD,CAAX,IAAkC,KAAKlB,IAAL,CAAUR,IAAV,CAAlC,IAAqD,CAAChC,QAAQ,CAACwC,IAAT,CAAcR,IAAd,CAAtD,IAA6E,CAACC,oBAAoB,CAACD,IAAD,CADlG,EAC2G;UAC5G;UACA;UACA,IAAIhD,QAAQ,CAACN,GAAD,CAAR,KAAkBf,SAAtB,EAAiC;YAC7B,IAAM2G,MAAM,GAAGtF,QAAQ,CAACN,GAAD,CAAvB;YACA0F,SAAS,GAAGrD,KAAK,CAACC,OAAN,CAAcsD,MAAd,IAAwBA,MAAxB,GAAiC,CAACA,MAAD,CAA7C;UACH;QACJ,CARI,MASA;UACD;UACA,IAAI,CAACR,WAAW,CAACJ,iBAAD,CAAhB,EAAqC;YACjCU,SAAS,CAACxD,IAAV,CAAe2D,YAAY,CAAC7F,GAAD,EAAMgF,iBAAN,EAAyB,IAAzB,CAA3B;UACH;;UACD,KAAK,IAAIC,EAAE,GAAGnC,CAAC,GAAG,CAAlB,EAAqBmC,EAAE,GAAGhF,IAAI,CAAC8C,MAA/B,EAAuCkC,EAAE,EAAzC,EAA6C;YACzC,IAAK,CAAC3F,aAAa,CAAC,eAAD,CAAd,IAAmCoG,SAAS,CAAC3C,MAAV,GAAmB,CAAvD,IACC4C,UAAU,IAAI,OAAOA,UAAP,KAAsB,QAApC,IAAgDD,SAAS,CAAC3C,MAAV,IAAoB4C,UADzE,EAEI;YACJrC,IAAI,GAAGrD,IAAI,CAACgF,EAAD,CAAX;YACA,IAAI,KAAKnB,IAAL,CAAUR,IAAV,KAAmB,CAAChC,QAAQ,CAACwC,IAAT,CAAcR,IAAd,CAApB,IAA2C,CAACC,oBAAoB,CAACD,IAAD,CAApE,EACI;YACJR,CAAC,GAAGmC,EAAJ;YACAS,SAAS,CAACxD,IAAV,CAAe2D,YAAY,CAAC7F,GAAD,EAAMsD,IAAN,EAAYpD,aAAZ,CAA3B;UACH;QACJ,CAhC8C,CAiC/C;QACA;QACA;;;QACA,IAAI,OAAOyF,UAAP,KAAsB,QAAtB,KAAoCA,UAAU,IAAID,SAAS,CAAC3C,MAAV,GAAmB4C,UAAlC,IAClCR,KAAK,CAACQ,UAAD,CAAL,IAAqBD,SAAS,CAAC3C,MAAV,KAAqB,CAD3C,CAAJ,EACoD;UAChDP,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,oCAAD,EAAuCC,GAAvC,CAAH,CAAb;QACH;;QACD6D,MAAM,CAAC7D,GAAD,EAAM0F,SAAN,CAAN;QACA,OAAO5C,CAAP;MACH;;MACD,SAASe,MAAT,CAAgB7D,GAAhB,EAAqB8F,GAArB,EAA6D;QAAA,IAAnCC,iBAAmC,uEAAf7F,aAAe;;QACzD,IAAI,IAAI4D,IAAJ,CAAS9D,GAAT,KAAiBV,aAAa,CAAC,sBAAD,CAAlC,EAA4D;UACxD,IAAMN,KAAK,GAAGgB,GAAG,CAACiE,KAAJ,CAAU,GAAV,EAAelC,GAAf,CAAmB,UAAU6C,IAAV,EAAgB;YAC7C,OAAOvG,SAAS,CAACuG,IAAD,CAAhB;UACH,CAFa,EAEXC,IAFW,CAEN,GAFM,CAAd;UAGAmB,WAAW,CAAChG,GAAD,EAAMhB,KAAN,CAAX;QACH;;QACD,IAAMoD,KAAK,GAAGyD,YAAY,CAAC7F,GAAD,EAAM8F,GAAN,EAAWC,iBAAX,CAA1B;QACA,IAAME,QAAQ,GAAGjG,GAAG,CAACiE,KAAJ,CAAU,GAAV,CAAjB;QACAiC,MAAM,CAACvD,IAAD,EAAOsD,QAAP,EAAiB7D,KAAjB,CAAN,CATyD,CAUzD;;QACA,IAAIxB,KAAK,CAACT,OAAN,CAAcH,GAAd,CAAJ,EAAwB;UACpBY,KAAK,CAACT,OAAN,CAAcH,GAAd,EAAmB4B,OAAnB,CAA2B,UAAUuE,CAAV,EAAa;YACpC,IAAMC,aAAa,GAAGD,CAAC,CAAClC,KAAF,CAAQ,GAAR,CAAtB;YACAiC,MAAM,CAACvD,IAAD,EAAOyD,aAAP,EAAsBhE,KAAtB,CAAN;UACH,CAHD;QAIH,CAhBwD,CAiBzD;;;QACA,IAAI6D,QAAQ,CAAClD,MAAT,GAAkB,CAAlB,IAAuBzD,aAAa,CAAC,cAAD,CAAxC,EAA0D;UACtD;UACA,CAACsB,KAAK,CAACT,OAAN,CAAc8F,QAAQ,CAAC,CAAD,CAAtB,KAA8B,EAA/B,EAAmCrE,OAAnC,CAA2C,UAAUuE,CAAV,EAAa;YACpD,IAAIC,aAAa,GAAGD,CAAC,CAAClC,KAAF,CAAQ,GAAR,CAApB,CADoD,CAEpD;;YACA,IAAMoC,CAAC,GAAG,GAAG5E,MAAH,CAAUwE,QAAV,CAAV;YACAI,CAAC,CAACC,KAAF,GAJoD,CAIzC;;YACXF,aAAa,GAAGA,aAAa,CAAC3E,MAAd,CAAqB4E,CAArB,CAAhB,CALoD,CAMpD;YACA;;YACA,IAAI,CAAC,CAACzF,KAAK,CAACT,OAAN,CAAcH,GAAd,KAAsB,EAAvB,EAA2B0E,QAA3B,CAAoC0B,aAAa,CAACvB,IAAd,CAAmB,GAAnB,CAApC,CAAL,EAAmE;cAC/DqB,MAAM,CAACvD,IAAD,EAAOyD,aAAP,EAAsBhE,KAAtB,CAAN;YACH;UACJ,CAXD;QAYH,CAhCwD,CAiCzD;;;QACA,IAAIsB,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAAChB,SAAZ,CAAf,IAAyC,CAAC8D,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACC,MAAZ,CAA7D,EAAkF;UAC9E,IAAMQ,IAAI,GAAG,CAACrB,GAAD,EAAMyB,MAAN,CAAab,KAAK,CAACT,OAAN,CAAcH,GAAd,KAAsB,EAAnC,CAAb;UACAqB,IAAI,CAACO,OAAL,CAAa,UAAU5B,GAAV,EAAe;YACxBlB,MAAM,CAACyH,cAAP,CAAsB1D,UAAtB,EAAkC7C,GAAlC,EAAuC;cACnCwG,UAAU,EAAE,IADuB;cAEnCC,GAFmC,iBAE7B;gBACF,OAAOX,GAAP;cACH,CAJkC;cAKnCY,GALmC,eAK/BtE,KAL+B,EAKxB;gBACP0D,GAAG,GAAG,OAAO1D,KAAP,KAAiB,QAAjB,GAA4B5D,KAAK,CAACoB,SAAN,CAAgBwC,KAAhB,CAA5B,GAAqDA,KAA3D;cACH;YAPkC,CAAvC;UASH,CAVD;QAWH;MACJ;;MACD,SAAS4D,WAAT,CAAqBhG,GAArB,EAA0BhB,KAA1B,EAAiC;QAC7B,IAAI,EAAE4B,KAAK,CAACT,OAAN,CAAcH,GAAd,KAAsBY,KAAK,CAACT,OAAN,CAAcH,GAAd,EAAmB+C,MAA3C,CAAJ,EAAwD;UACpDnC,KAAK,CAACT,OAAN,CAAcH,GAAd,IAAqB,CAAChB,KAAD,CAArB;UACAyB,UAAU,CAACzB,KAAD,CAAV,GAAoB,IAApB;QACH;;QACD,IAAI,EAAE4B,KAAK,CAACT,OAAN,CAAcnB,KAAd,KAAwB4B,KAAK,CAACT,OAAN,CAAcnB,KAAd,EAAqB+D,MAA/C,CAAJ,EAA4D;UACxDiD,WAAW,CAAChH,KAAD,EAAQgB,GAAR,CAAX;QACH;MACJ;;MACD,SAAS6F,YAAT,CAAsB7F,GAAtB,EAA2B8F,GAA3B,EAAgCC,iBAAhC,EAAmD;QAC/C;QACA,IAAIA,iBAAJ,EAAuB;UACnBD,GAAG,GAAGa,WAAW,CAACb,GAAD,CAAjB;QACH,CAJ8C,CAK/C;;;QACA,IAAIpC,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACE,KAAZ,CAAf,IAAqC4C,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACK,MAAZ,CAAxD,EAA6E;UACzE,IAAI,OAAO6E,GAAP,KAAe,QAAnB,EACIA,GAAG,GAAGA,GAAG,KAAK,MAAd;QACP;;QACD,IAAI1D,KAAK,GAAGC,KAAK,CAACC,OAAN,CAAcwD,GAAd,IACNA,GAAG,CAAC/D,GAAJ,CAAQ,UAAU6E,CAAV,EAAa;UAAE,OAAO7B,iBAAiB,CAAC/E,GAAD,EAAM4G,CAAN,CAAxB;QAAmC,CAA1D,CADM,GAEN7B,iBAAiB,CAAC/E,GAAD,EAAM8F,GAAN,CAFvB,CAV+C,CAa/C;;QACA,IAAIpC,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACK,MAAZ,CAAf,KAAuCmE,WAAW,CAAChD,KAAD,CAAX,IAAsB,OAAOA,KAAP,KAAiB,SAA9E,CAAJ,EAA8F;UAC1FA,KAAK,GAAGyE,SAAS,EAAjB;QACH,CAhB8C,CAiB/C;;;QACA,IAAInD,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAAChB,SAAZ,CAAf,IAAyC8D,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACC,MAAZ,CAA5D,EAAiF;UAC7E,IAAIwB,KAAK,CAACC,OAAN,CAAcwD,GAAd,CAAJ,EACI1D,KAAK,GAAG0D,GAAG,CAAC/D,GAAJ,CAAQ,UAAC+D,GAAD,EAAS;YAAE,OAAOtH,KAAK,CAACoB,SAAN,CAAgBkG,GAAhB,CAAP;UAA8B,CAAjD,CAAR,CADJ,KAGI1D,KAAK,GAAG5D,KAAK,CAACoB,SAAN,CAAgBkG,GAAhB,CAAR;QACP;;QACD,OAAO1D,KAAP;MACH;;MACD,SAAS2C,iBAAT,CAA2B/E,GAA3B,EAAgCoC,KAAhC,EAAuC;QACnC,IAAI,CAAC9C,aAAa,CAAC,0BAAD,CAAd,IAA8CU,GAAG,KAAK,GAA1D,EACI,OAAOoC,KAAP;;QACJ,IAAI,CAACsB,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACG,OAAZ,CAAhB,IAAwC,CAAC2C,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACE,KAAZ,CAAxD,IAA8E,CAACuB,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAnF,EAAyG;UACrG,IAAM0E,kBAAkB,GAAGvI,eAAe,CAAC6D,KAAD,CAAf,IAA0B9C,aAAa,CAAC,eAAD,CAAvC,IAA6DyH,MAAM,CAACC,aAAP,CAAqBxB,IAAI,CAACyB,KAAL,CAAWC,UAAU,WAAI9E,KAAJ,EAArB,CAArB,CAAxF;;UACA,IAAI0E,kBAAkB,IAAK,CAAC1B,WAAW,CAAChD,KAAD,CAAZ,IAAuBsB,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACI,OAAZ,CAAjE,EAAwF;YACpFoB,KAAK,GAAG2E,MAAM,CAAC3E,KAAD,CAAd;UACH;QACJ;;QACD,OAAOA,KAAP;MACH,CAvkBqB,CAwkBtB;MACA;;;MACA,SAASgC,SAAT,CAAmBzB,IAAnB,EAAyB;QACrB,IAAMwE,YAAY,GAAGrI,MAAM,CAACuB,MAAP,CAAc,IAAd,CAArB,CADqB,CAErB;QACA;;QACAiE,uBAAuB,CAAC6C,YAAD,EAAevG,KAAK,CAACT,OAArB,EAA8BG,QAA9B,CAAvB;QACAxB,MAAM,CAACuC,IAAP,CAAYT,KAAK,CAACM,OAAlB,EAA2BU,OAA3B,CAAmC,UAAUwF,SAAV,EAAqB;UACpD,IAAMC,UAAU,GAAG1E,IAAI,CAACyE,SAAD,CAAJ,IAAmBD,YAAY,CAACC,SAAD,CAAlD;;UACA,IAAIC,UAAJ,EAAgB;YACZ,IAAI;cACA,IAAIjI,MAAM,GAAG,IAAb;cACA,IAAMkI,kBAAkB,GAAG9I,KAAK,CAAC+I,OAAN,CAAc/I,KAAK,CAACgJ,GAAN,EAAd,EAA2BH,UAA3B,CAA3B;cACA,IAAMI,aAAa,GAAG7G,KAAK,CAACM,OAAN,CAAckG,SAAd,CAAtB;;cACA,IAAI,OAAOK,aAAP,KAAyB,UAA7B,EAAyC;gBACrC,IAAI;kBACArI,MAAM,GAAGqI,aAAa,CAACH,kBAAD,CAAtB;gBACH,CAFD,CAGA,OAAOI,CAAP,EAAU;kBACNtI,MAAM,GAAGsI,CAAT;gBACH;;gBACD,IAAItI,MAAM,YAAYiG,KAAtB,EAA6B;kBACzB7C,KAAK,GAAGpD,MAAR;kBACA;gBACH;cACJ,CAXD,MAYK;gBACDA,MAAM,GAAGZ,KAAK,CAACmJ,OAAN,CAAcL,kBAAd,CAAT;cACH;;cACDM,eAAe,CAACxI,MAAD,CAAf;YACH,CApBD,CAqBA,OAAOyI,EAAP,EAAW;cACP;cACA;cACA,IAAIA,EAAE,CAACC,IAAH,KAAY,kBAAhB,EACItF,KAAK,GAAGqF,EAAR,CADJ,KAEK,IAAIlF,IAAI,CAACyE,SAAD,CAAR,EACD5E,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,8BAAD,EAAiCsH,UAAjC,CAAH,CAAb;YACP;UACJ;QACJ,CAjCD;MAkCH,CAjnBqB,CAknBtB;MACA;;;MACA,SAASO,eAAT,CAAyBxI,MAAzB,EAAiC2I,IAAjC,EAAuC;QACnCjJ,MAAM,CAACuC,IAAP,CAAYjC,MAAZ,EAAoBwC,OAApB,CAA4B,UAAU5B,GAAV,EAAe;UACvC,IAAMoC,KAAK,GAAGhD,MAAM,CAACY,GAAD,CAApB;UACA,IAAMgI,OAAO,GAAGD,IAAI,GAAGA,IAAI,GAAG,GAAP,GAAa/H,GAAhB,GAAsBA,GAA1C,CAFuC,CAGvC;UACA;UACA;;UACA,IAAI,OAAOoC,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,IAA+C,CAACC,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAhD,IAAwE9C,aAAa,CAAC,cAAD,CAAzF,EAA2G;YACvG;YACAsI,eAAe,CAACxF,KAAD,EAAQ4F,OAAR,CAAf;UACH,CAHD,MAIK;YACD;YACA;YACA,IAAI,CAACvD,MAAM,CAAC9B,IAAD,EAAOqF,OAAO,CAAC/D,KAAR,CAAc,GAAd,CAAP,CAAP,IAAsCP,eAAe,CAACsE,OAAD,EAAUpH,KAAK,CAACC,MAAhB,CAAf,IAA0CvB,aAAa,CAAC,gBAAD,CAAjG,EAAsH;cAClHuE,MAAM,CAACmE,OAAD,EAAU5F,KAAV,CAAN;YACH;UACJ;QACJ,CAjBD;MAkBH,CAvoBqB,CAwoBtB;;;MACA,SAASiC,gBAAT,GAA4B;QACxB,IAAI,OAAOhF,aAAP,KAAyB,WAA7B,EAA0C;UACtCA,aAAa,CAACuC,OAAd,CAAsB,UAAUqG,YAAV,EAAwB;YAC1CL,eAAe,CAACK,YAAD,CAAf;UACH,CAFD;QAGH;MACJ;;MACD,SAAS9D,YAAT,CAAsBxB,IAAtB,EAA4BuF,UAA5B,EAAwC;QACpC,IAAI,OAAOxI,SAAP,KAAqB,WAAzB,EACI;QACJ,IAAMyI,MAAM,GAAG,OAAOzI,SAAP,KAAqB,QAArB,GAAgCA,SAAhC,GAA4C,EAA3D;QACA,IAAM0I,GAAG,GAAG5J,KAAK,CAAC4J,GAAN,EAAZ;QACAtJ,MAAM,CAACuC,IAAP,CAAY+G,GAAZ,EAAiBxG,OAAjB,CAAyB,UAAUyG,MAAV,EAAkB;UACvC,IAAIF,MAAM,KAAK,EAAX,IAAiBE,MAAM,CAACC,WAAP,CAAmBH,MAAnB,EAA2B,CAA3B,MAAkC,CAAvD,EAA0D;YACtD;YACA,IAAM9G,IAAI,GAAGgH,MAAM,CAACpE,KAAP,CAAa,IAAb,EAAmBlC,GAAnB,CAAuB,UAAU/B,GAAV,EAAe8C,CAAf,EAAkB;cAClD,IAAIA,CAAC,KAAK,CAAV,EAAa;gBACT9C,GAAG,GAAGA,GAAG,CAACuI,SAAJ,CAAcJ,MAAM,CAACpF,MAArB,CAAN;cACH;;cACD,OAAO1E,SAAS,CAAC2B,GAAD,CAAhB;YACH,CALY,CAAb;;YAMA,IAAI,CAAEkI,UAAU,IAAItH,KAAK,CAACM,OAAN,CAAcG,IAAI,CAACwD,IAAL,CAAU,GAAV,CAAd,CAAf,IAAiD,CAACqD,UAAnD,KAAkE,CAACzD,MAAM,CAAC9B,IAAD,EAAOtB,IAAP,CAA7E,EAA2F;cACvFwC,MAAM,CAACxC,IAAI,CAACwD,IAAL,CAAU,GAAV,CAAD,EAAiBuD,GAAG,CAACC,MAAD,CAApB,CAAN;YACH;UACJ;QACJ,CAbD;MAcH;;MACD,SAAS9D,cAAT,CAAwB5B,IAAxB,EAA8B;QAC1B,IAAIpD,MAAJ;QACA,IAAMiJ,OAAO,GAAG,IAAIC,GAAJ,EAAhB;QACA3J,MAAM,CAACuC,IAAP,CAAYsB,IAAZ,EAAkBf,OAAlB,CAA0B,UAAU5B,GAAV,EAAe;UACrC,IAAI,CAACwI,OAAO,CAACE,GAAR,CAAY1I,GAAZ,CAAL,EAAuB;YAAE;YACrBT,MAAM,GAAGmE,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACQ,SAAZ,CAAxB;;YACA,IAAI,OAAO7B,MAAP,KAAkB,UAAtB,EAAkC;cAC9B,IAAI;gBACA,IAAM6C,MAAK,GAAG2C,iBAAiB,CAAC/E,GAAD,EAAMT,MAAM,CAACoD,IAAI,CAAC3C,GAAD,CAAL,CAAZ,CAA/B;;gBACC,GAAGyB,MAAH,CAAUb,KAAK,CAACT,OAAN,CAAcH,GAAd,KAAsB,EAAhC,EAAoCA,GAApC,CAAD,CAA2C4B,OAA3C,CAAmD,UAAA+G,GAAG,EAAI;kBACtDH,OAAO,CAACI,GAAR,CAAYD,GAAZ;kBACAhG,IAAI,CAACgG,GAAD,CAAJ,GAAYvG,MAAZ;gBACH,CAHD;cAIH,CAND,CAOA,OAAOyG,GAAP,EAAY;gBACRrG,KAAK,GAAGqG,GAAR;cACH;YACJ;UACJ;QACJ,CAhBD;MAiBH;;MACD,SAASrE,kBAAT,CAA4B7B,IAA5B,EAAkC;QAC9B/B,KAAK,CAACS,IAAN,CAAWO,OAAX,CAAmB,UAAC5B,GAAD,EAAS;UACxB;UACA,IAAI,CAACA,GAAG,CAAC8I,OAAJ,CAAY,GAAZ,CAAL,EACI;UACJ,IAAI,OAAOnG,IAAI,CAAC3C,GAAD,CAAX,KAAqB,WAAzB,EACI2C,IAAI,CAAC3C,GAAD,CAAJ,GAAYf,SAAZ;QACP,CAND;QAOA,OAAO0D,IAAP;MACH;;MACD,SAAS2B,uBAAT,CAAiCyE,GAAjC,EAAsC5I,OAAtC,EAA+CG,QAA/C,EAAyE;QAAA,IAAhB0I,MAAgB,uEAAP,KAAO;QACrElK,MAAM,CAACuC,IAAP,CAAYf,QAAZ,EAAsBsB,OAAtB,CAA8B,UAAU5B,GAAV,EAAe;UACzC,IAAI,CAACyE,MAAM,CAACsE,GAAD,EAAM/I,GAAG,CAACiE,KAAJ,CAAU,GAAV,CAAN,CAAX,EAAkC;YAC9BiC,MAAM,CAAC6C,GAAD,EAAM/I,GAAG,CAACiE,KAAJ,CAAU,GAAV,CAAN,EAAsB3D,QAAQ,CAACN,GAAD,CAA9B,CAAN;YACA,IAAIgJ,MAAJ,EACItI,SAAS,CAACV,GAAD,CAAT,GAAiB,IAAjB;YACJ,CAACG,OAAO,CAACH,GAAD,CAAP,IAAgB,EAAjB,EAAqB4B,OAArB,CAA6B,UAAUuE,CAAV,EAAa;cACtC,IAAI1B,MAAM,CAACsE,GAAD,EAAM5C,CAAC,CAAClC,KAAF,CAAQ,GAAR,CAAN,CAAV,EACI;cACJiC,MAAM,CAAC6C,GAAD,EAAM5C,CAAC,CAAClC,KAAF,CAAQ,GAAR,CAAN,EAAoB3D,QAAQ,CAACN,GAAD,CAA5B,CAAN;YACH,CAJD;UAKH;QACJ,CAXD;MAYH;;MACD,SAASyE,MAAT,CAAgBsE,GAAhB,EAAqB1H,IAArB,EAA2B;QACvB,IAAI4H,CAAC,GAAGF,GAAR;QACA,IAAI,CAACzJ,aAAa,CAAC,cAAD,CAAlB,EACI+B,IAAI,GAAG,CAACA,IAAI,CAACwD,IAAL,CAAU,GAAV,CAAD,CAAP;QACJxD,IAAI,CAAC2C,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,EAAkBpC,OAAlB,CAA0B,UAAU5B,GAAV,EAAe;UACrCiJ,CAAC,GAAIA,CAAC,CAACjJ,GAAD,CAAD,IAAU,EAAf;QACH,CAFD;QAGA,IAAMA,GAAG,GAAGqB,IAAI,CAACA,IAAI,CAAC0B,MAAL,GAAc,CAAf,CAAhB;QACA,IAAI,OAAOkG,CAAP,KAAa,QAAjB,EACI,OAAO,KAAP,CADJ,KAGI,OAAOjJ,GAAG,IAAIiJ,CAAd;MACP;;MACD,SAAS/C,MAAT,CAAgB6C,GAAhB,EAAqB1H,IAArB,EAA2Be,KAA3B,EAAkC;QAC9B,IAAI6G,CAAC,GAAGF,GAAR;QACA,IAAI,CAACzJ,aAAa,CAAC,cAAD,CAAlB,EACI+B,IAAI,GAAG,CAACA,IAAI,CAACwD,IAAL,CAAU,GAAV,CAAD,CAAP;QACJxD,IAAI,CAAC2C,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,EAAkBpC,OAAlB,CAA0B,UAAU5B,GAAV,EAAe;UACrC;UACA;UACAA,GAAG,GAAGkJ,WAAW,CAAClJ,GAAD,CAAjB;;UACA,IAAI,OAAOiJ,CAAP,KAAa,QAAb,IAAyBA,CAAC,CAACjJ,GAAD,CAAD,KAAWf,SAAxC,EAAmD;YAC/CgK,CAAC,CAACjJ,GAAD,CAAD,GAAS,EAAT;UACH;;UACD,IAAI,OAAOiJ,CAAC,CAACjJ,GAAD,CAAR,KAAkB,QAAlB,IAA8BqC,KAAK,CAACC,OAAN,CAAc2G,CAAC,CAACjJ,GAAD,CAAf,CAAlC,EAAyD;YACrD;YACA,IAAIqC,KAAK,CAACC,OAAN,CAAc2G,CAAC,CAACjJ,GAAD,CAAf,CAAJ,EAA2B;cACvBiJ,CAAC,CAACjJ,GAAD,CAAD,CAAOkC,IAAP,CAAY,EAAZ;YACH,CAFD,MAGK;cACD+G,CAAC,CAACjJ,GAAD,CAAD,GAAS,CAACiJ,CAAC,CAACjJ,GAAD,CAAF,EAAS,EAAT,CAAT;YACH,CAPoD,CAQrD;;;YACAiJ,CAAC,GAAGA,CAAC,CAACjJ,GAAD,CAAD,CAAOiJ,CAAC,CAACjJ,GAAD,CAAD,CAAO+C,MAAP,GAAgB,CAAvB,CAAJ;UACH,CAVD,MAWK;YACDkG,CAAC,GAAGA,CAAC,CAACjJ,GAAD,CAAL;UACH;QACJ,CArBD,EAJ8B,CA0B9B;QACA;;QACA,IAAMA,GAAG,GAAGkJ,WAAW,CAAC7H,IAAI,CAACA,IAAI,CAAC0B,MAAL,GAAc,CAAf,CAAL,CAAvB;QACA,IAAMoG,WAAW,GAAGzF,eAAe,CAACrC,IAAI,CAACwD,IAAL,CAAU,GAAV,CAAD,EAAiBjE,KAAK,CAACC,MAAvB,CAAnC;QACA,IAAMuI,YAAY,GAAG/G,KAAK,CAACC,OAAN,CAAcF,KAAd,CAArB;QACA,IAAIiH,SAAS,GAAG/J,aAAa,CAAC,2BAAD,CAA7B,CA/B8B,CAgC9B;;QACA,IAAI,CAAC+J,SAAD,IAAc3F,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACO,KAAZ,CAAjC,EAAqD;UACjDkI,SAAS,GAAG,IAAZ;;UACA,IAAK,CAACjE,WAAW,CAAC6D,CAAC,CAACjJ,GAAD,CAAF,CAAZ,IAAwBY,KAAK,CAACO,KAAN,CAAYnB,GAAZ,MAAqB,CAA9C,IAAqDqC,KAAK,CAACC,OAAN,CAAc2G,CAAC,CAACjJ,GAAD,CAAf,KAAyBiJ,CAAC,CAACjJ,GAAD,CAAD,CAAO+C,MAAP,KAAkBnC,KAAK,CAACO,KAAN,CAAYnB,GAAZ,CAApG,EAAuH;YACnHiJ,CAAC,CAACjJ,GAAD,CAAD,GAASf,SAAT;UACH;QACJ;;QACD,IAAImD,KAAK,KAAKyE,SAAS,EAAvB,EAA2B;UACvBoC,CAAC,CAACjJ,GAAD,CAAD,GAAS6G,SAAS,CAACoC,CAAC,CAACjJ,GAAD,CAAF,CAAlB;QACH,CAFD,MAGK,IAAIqC,KAAK,CAACC,OAAN,CAAc2G,CAAC,CAACjJ,GAAD,CAAf,CAAJ,EAA2B;UAC5B,IAAIqJ,SAAS,IAAIF,WAAb,IAA4BC,YAAhC,EAA8C;YAC1CH,CAAC,CAACjJ,GAAD,CAAD,GAASV,aAAa,CAAC,0BAAD,CAAb,GAA4C2J,CAAC,CAACjJ,GAAD,CAAD,CAAOyB,MAAP,CAAcW,KAAd,CAA5C,GAAmE,CAACC,KAAK,CAACC,OAAN,CAAc2G,CAAC,CAACjJ,GAAD,CAAD,CAAO,CAAP,CAAd,IAA2BiJ,CAAC,CAACjJ,GAAD,CAA5B,GAAoC,CAACiJ,CAAC,CAACjJ,GAAD,CAAF,CAArC,EAA+CyB,MAA/C,CAAsD,CAACW,KAAD,CAAtD,CAA5E;UACH,CAFD,MAGK,IAAI,CAACiH,SAAD,IAAc1H,OAAO,CAACwH,WAAD,CAAP,KAAyBxH,OAAO,CAACyH,YAAD,CAAlD,EAAkE;YACnEH,CAAC,CAACjJ,GAAD,CAAD,GAASoC,KAAT;UACH,CAFI,MAGA;YACD6G,CAAC,CAACjJ,GAAD,CAAD,GAASiJ,CAAC,CAACjJ,GAAD,CAAD,CAAOyB,MAAP,CAAc,CAACW,KAAD,CAAd,CAAT;UACH;QACJ,CAVI,MAWA,IAAI6G,CAAC,CAACjJ,GAAD,CAAD,KAAWf,SAAX,IAAwBkK,WAA5B,EAAyC;UAC1CF,CAAC,CAACjJ,GAAD,CAAD,GAASoJ,YAAY,GAAGhH,KAAH,GAAW,CAACA,KAAD,CAAhC;QACH,CAFI,MAGA,IAAIiH,SAAS,IAAI,EAAEJ,CAAC,CAACjJ,GAAD,CAAD,KAAWf,SAAX,IACpByE,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACK,MAAZ,CADK,IAEpByC,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACE,KAAZ,CAFG,CAAjB,EAEmC;UACpCmI,CAAC,CAACjJ,GAAD,CAAD,GAAS,CAACiJ,CAAC,CAACjJ,GAAD,CAAF,EAASoC,KAAT,CAAT;QACH,CAJI,MAKA;UACD6G,CAAC,CAACjJ,GAAD,CAAD,GAASoC,KAAT;QACH;MACJ,CA9xBqB,CA+xBtB;;;MACA,SAASG,aAAT,GAAgC;QAAA,kCAANtC,IAAM;UAANA,IAAM;QAAA;;QAC5BA,IAAI,CAAC2B,OAAL,CAAa,UAAUmH,GAAV,EAAe;UACxBjK,MAAM,CAACuC,IAAP,CAAY0H,GAAG,IAAI,EAAnB,EAAuBnH,OAAvB,CAA+B,UAAU5B,GAAV,EAAe;YAC1C;YACA;YACA;YACA,IAAIY,KAAK,CAACT,OAAN,CAAcH,GAAd,CAAJ,EACI;YACJY,KAAK,CAACT,OAAN,CAAcH,GAAd,IAAqB,GAAGyB,MAAH,CAAUtB,OAAO,CAACH,GAAD,CAAP,IAAgB,EAA1B,CAArB,CAN0C,CAO1C;;YACAY,KAAK,CAACT,OAAN,CAAcH,GAAd,EAAmByB,MAAnB,CAA0BzB,GAA1B,EAA+B4B,OAA/B,CAAuC,UAAUuE,CAAV,EAAa;cAChD,IAAI,IAAIrC,IAAJ,CAASqC,CAAT,KAAe7G,aAAa,CAAC,sBAAD,CAAhC,EAA0D;gBACtD,IAAMgK,CAAC,GAAGjL,SAAS,CAAC8H,CAAD,CAAnB;;gBACA,IAAImD,CAAC,KAAKtJ,GAAN,IAAaY,KAAK,CAACT,OAAN,CAAcH,GAAd,EAAmB8I,OAAnB,CAA2BQ,CAA3B,MAAkC,CAAC,CAApD,EAAuD;kBACnD1I,KAAK,CAACT,OAAN,CAAcH,GAAd,EAAmBkC,IAAnB,CAAwBoH,CAAxB;kBACA7I,UAAU,CAAC6I,CAAD,CAAV,GAAgB,IAAhB;gBACH;cACJ;YACJ,CARD,EAR0C,CAiB1C;;YACA1I,KAAK,CAACT,OAAN,CAAcH,GAAd,EAAmByB,MAAnB,CAA0BzB,GAA1B,EAA+B4B,OAA/B,CAAuC,UAAUuE,CAAV,EAAa;cAChD,IAAIA,CAAC,CAACpD,MAAF,GAAW,CAAX,IAAgB,QAAQe,IAAR,CAAaqC,CAAb,CAAhB,IAAmC7G,aAAa,CAAC,sBAAD,CAApD,EAA8E;gBAC1E,IAAMgK,CAAC,GAAGhL,UAAU,CAAC6H,CAAD,EAAI,GAAJ,CAApB;;gBACA,IAAImD,CAAC,KAAKtJ,GAAN,IAAaY,KAAK,CAACT,OAAN,CAAcH,GAAd,EAAmB8I,OAAnB,CAA2BQ,CAA3B,MAAkC,CAAC,CAApD,EAAuD;kBACnD1I,KAAK,CAACT,OAAN,CAAcH,GAAd,EAAmBkC,IAAnB,CAAwBoH,CAAxB;kBACA7I,UAAU,CAAC6I,CAAD,CAAV,GAAgB,IAAhB;gBACH;cACJ;YACJ,CARD;YASA1I,KAAK,CAACT,OAAN,CAAcH,GAAd,EAAmB4B,OAAnB,CAA2B,UAAUuE,CAAV,EAAa;cACpCvF,KAAK,CAACT,OAAN,CAAcgG,CAAd,IAAmB,CAACnG,GAAD,EAAMyB,MAAN,CAAab,KAAK,CAACT,OAAN,CAAcH,GAAd,EAAmB0B,MAAnB,CAA0B,UAAU6H,CAAV,EAAa;gBACnE,OAAOpD,CAAC,KAAKoD,CAAb;cACH,CAF+B,CAAb,CAAnB;YAGH,CAJD;UAKH,CAhCD;QAiCH,CAlCD;MAmCH;;MACD,SAAS7F,eAAT,CAAyB1D,GAAzB,EAA8BwJ,IAA9B,EAAoC;QAChC,IAAMC,OAAO,GAAG,GAAGhI,MAAH,CAAUb,KAAK,CAACT,OAAN,CAAcH,GAAd,KAAsB,EAAhC,EAAoCA,GAApC,CAAhB;QACA,IAAMqB,IAAI,GAAGvC,MAAM,CAACuC,IAAP,CAAYmI,IAAZ,CAAb;QACA,IAAME,QAAQ,GAAGD,OAAO,CAACE,IAAR,CAAa,UAAA3J,GAAG;UAAA,OAAIqB,IAAI,CAACqD,QAAL,CAAc1E,GAAd,CAAJ;QAAA,CAAhB,CAAjB;QACA,OAAO0J,QAAQ,GAAGF,IAAI,CAACE,QAAD,CAAP,GAAoB,KAAnC;MACH;;MACD,SAASE,UAAT,CAAoB5J,GAApB,EAAyB;QACrB,IAAM6J,SAAS,GAAG/K,MAAM,CAACuC,IAAP,CAAYT,KAAZ,CAAlB;QACA,IAAM6I,OAAO,GAAG,GAAGhI,MAAH,CAAUoI,SAAS,CAAC9H,GAAV,CAAc,UAAA4C,CAAC;UAAA,OAAI/D,KAAK,CAAC+D,CAAD,CAAT;QAAA,CAAf,CAAV,CAAhB;QACA,OAAO8E,OAAO,CAACK,IAAR,CAAa,UAAUN,IAAV,EAAgB;UAChC,OAAOnH,KAAK,CAACC,OAAN,CAAckH,IAAd,IAAsBA,IAAI,CAAC9E,QAAL,CAAc1E,GAAd,CAAtB,GAA2CwJ,IAAI,CAACxJ,GAAD,CAAtD;QACH,CAFM,CAAP;MAGH;;MACD,SAAS+J,gBAAT,CAA0B/G,GAA1B,EAA4C;QAAA;;QAAA,mCAAVgH,QAAU;UAAVA,QAAU;QAAA;;QACxC,IAAMP,OAAO,GAAG,aAAGhI,MAAH,cAAauI,QAAb,CAAhB;;QACA,OAAOP,OAAO,CAACK,IAAR,CAAa,UAAUG,OAAV,EAAmB;UACnC,IAAMxG,KAAK,GAAGT,GAAG,CAACS,KAAJ,CAAUwG,OAAV,CAAd;UACA,OAAOxG,KAAK,IAAImG,UAAU,CAACnG,KAAK,CAAC,CAAD,CAAN,CAA1B;QACH,CAHM,CAAP;MAIH,CAx1BqB,CAy1BtB;;;MACA,SAASyG,gBAAT,CAA0BlH,GAA1B,EAA+B;QAC3B;QACA,IAAIA,GAAG,CAACS,KAAJ,CAAUnC,QAAV,KAAuB,CAAC0B,GAAG,CAACS,KAAJ,CAAU,SAAV,CAA5B,EAAkD;UAC9C,OAAO,KAAP;QACH;;QACD,IAAI0G,WAAW,GAAG,IAAlB;QACA,IAAI7G,IAAJ;QACA,IAAMF,OAAO,GAAGJ,GAAG,CAACgB,KAAJ,CAAU,CAAV,EAAaC,KAAb,CAAmB,EAAnB,CAAhB;;QACA,KAAK,IAAIC,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGd,OAAO,CAACL,MAA5B,EAAoCmB,EAAC,EAArC,EAAyC;UACrCZ,IAAI,GAAGN,GAAG,CAACgB,KAAJ,CAAUE,EAAC,GAAG,CAAd,CAAP;;UACA,IAAI,CAAC0F,UAAU,CAACxG,OAAO,CAACc,EAAD,CAAR,CAAf,EAA6B;YACzBiG,WAAW,GAAG,KAAd;YACA;UACH;;UACD,IAAK/G,OAAO,CAACc,EAAC,GAAG,CAAL,CAAP,IAAkBd,OAAO,CAACc,EAAC,GAAG,CAAL,CAAP,KAAmB,GAAtC,IACAZ,IAAI,KAAK,GADT,IAEC,WAAWQ,IAAX,CAAgBV,OAAO,CAACc,EAAD,CAAvB,KAA+B,2BAA2BJ,IAA3B,CAAgCR,IAAhC,CAFhC,IAGCF,OAAO,CAACc,EAAC,GAAG,CAAL,CAAP,IAAkBd,OAAO,CAACc,EAAC,GAAG,CAAL,CAAP,CAAeT,KAAf,CAAqB,IAArB,CAHvB,EAGoD;YAChD;UACH;QACJ;;QACD,OAAO0G,WAAP;MACH;;MACD,SAAS5G,oBAAT,CAA8BP,GAA9B,EAAmC;QAC/B,OAAO1D,aAAa,CAAC,yBAAD,CAAb,IAA4C8K,eAAe,CAACpH,GAAD,CAAlE;MACH;;MACD,SAASoH,eAAT,CAAyBpH,GAAzB,EAA8B;QAC1BA,GAAG,GAAGA,GAAG,CAACE,OAAJ,CAAY,QAAZ,EAAsB,IAAtB,CAAN,CAD0B,CAE1B;;QACA,IAAIF,GAAG,CAACS,KAAJ,CAAUnC,QAAV,CAAJ,EAAyB;UACrB,OAAO,KAAP;QACH,CALyB,CAM1B;;;QACA,IAAI4I,gBAAgB,CAAClH,GAAD,CAApB,EAA2B;UACvB,OAAO,KAAP;QACH,CATyB,CAU1B;;;QACA,IAAMqH,cAAc,GAAG,sBAAvB,CAX0B,CAY1B;;QACA,IAAMC,UAAU,GAAG,cAAnB,CAb0B,CAc1B;;QACA,IAAMC,kBAAkB,GAAG,eAA3B,CAf0B,CAgB1B;;QACA,IAAMC,kBAAkB,GAAG,iBAA3B,CAjB0B,CAkB1B;;QACA,IAAMC,6BAA6B,GAAG,mBAAtC,CAnB0B,CAoB1B;;QACA,OAAO,CAACV,gBAAgB,CAAC/G,GAAD,EAAMqH,cAAN,EAAsB9I,cAAtB,EAAsC+I,UAAtC,EAAkDC,kBAAlD,EAAsEC,kBAAtE,EAA0FC,6BAA1F,CAAxB;MACH,CA14BqB,CA24BtB;MACA;;;MACA,SAAS1G,YAAT,CAAsB/D,GAAtB,EAA2B;QACvB,IAAI,CAAC0D,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACE,KAAZ,CAAhB,IACA,CAAC4C,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACK,MAAZ,CADhB,IAEA,UAAGjB,GAAH,KAAYM,QAFhB,EAE0B;UACtB,OAAOA,QAAQ,CAACN,GAAD,CAAf;QACH,CAJD,MAKK;UACD,OAAO0K,cAAc,CAACC,SAAS,CAAC3K,GAAD,CAAV,CAArB;QACH;MACJ,CAt5BqB,CAu5BtB;;;MACA,SAAS0K,cAAT,CAAwBE,IAAxB,EAA8B;QAAA;;QAC1B,IAAMC,GAAG,qCACJzM,uBAAuB,CAAC0M,OADpB,EAC8B,IAD9B,yBAEJ1M,uBAAuB,CAAC2M,MAFpB,EAE6B,EAF7B,yBAGJ3M,uBAAuB,CAAC4M,MAHpB,EAG6B/L,SAH7B,yBAIJb,uBAAuB,CAAC6M,KAJpB,EAI4B,EAJ5B,QAAT;QAMA,OAAOJ,GAAG,CAACD,IAAD,CAAV;MACH,CAh6BqB,CAi6BtB;;;MACA,SAASD,SAAT,CAAmB3K,GAAnB,EAAwB;QACpB,IAAI4K,IAAI,GAAGxM,uBAAuB,CAAC0M,OAAnC;QACA,IAAIpH,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACG,OAAZ,CAAnB,EACI6J,IAAI,GAAGxM,uBAAuB,CAAC2M,MAA/B,CADJ,KAEK,IAAIrH,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACI,OAAZ,CAAnB,EACD4J,IAAI,GAAGxM,uBAAuB,CAAC4M,MAA/B,CADC,KAEA,IAAItH,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACE,KAAZ,CAAnB,EACD8J,IAAI,GAAGxM,uBAAuB,CAAC0M,OAA/B,CADC,KAEA,IAAIpH,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACC,MAAZ,CAAnB,EACD+J,IAAI,GAAGxM,uBAAuB,CAAC6M,KAA/B;QACJ,OAAOL,IAAP;MACH;;MACD,SAASxF,WAAT,CAAqB8F,GAArB,EAA0B;QACtB,OAAOA,GAAG,KAAKjM,SAAf;MACH,CAh7BqB,CAi7BtB;;;MACA,SAASwD,kBAAT,GAA8B;QAC1B;QACA3D,MAAM,CAACuC,IAAP,CAAYT,KAAK,CAACK,MAAlB,EAA0B0I,IAA1B,CAA+B,UAAA3J,GAAG,EAAI;UAClC,IAAI0D,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACC,MAAZ,CAAnB,EAAwC;YACpC2B,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,4DAAD,EAA+DC,GAA/D,CAAH,CAAb;YACA,OAAO,IAAP;UACH,CAHD,MAIK,IAAI0D,eAAe,CAAC1D,GAAD,EAAMY,KAAK,CAACO,KAAZ,CAAnB,EAAuC;YACxCqB,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,2DAAD,EAA8DC,GAA9D,CAAH,CAAb;YACA,OAAO,IAAP;UACH;;UACD,OAAO,KAAP;QACH,CAVD;MAWH;;MACD,OAAO;QACHG,OAAO,EAAErB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB6B,KAAK,CAACT,OAAxB,CADN;QAEHwC,IAAI,EAAE7D,MAAM,CAACC,MAAP,CAAc8D,UAAd,EAA0BF,IAA1B,CAFH;QAGHrD,aAAa,EAAEA,aAHZ;QAIHoB,SAAS,EAAE5B,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB2B,SAAlB,CAJR;QAKH8B,KAAK,EAAEA,KALJ;QAMH/B,UAAU,EAAE3B,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB0B,UAAlB;MANT,CAAP;IAQH;EA58BL;;EAAA;AAAA,I,CA88BA;AACA;;AACA,SAASL,cAAT,CAAwBD,OAAxB,EAAiC;EAC7B,IAAMgL,WAAW,GAAG,EAApB;EACA,IAAMC,QAAQ,GAAGtM,MAAM,CAACuB,MAAP,CAAc,IAAd,CAAjB;EACA,IAAIgL,MAAM,GAAG,IAAb,CAH6B,CAI7B;EACA;;EACAvM,MAAM,CAACuC,IAAP,CAAYlB,OAAZ,EAAqByB,OAArB,CAA6B,UAAU5B,GAAV,EAAe;IACxCmL,WAAW,CAACjJ,IAAZ,CAAiB,GAAGT,MAAH,CAAUtB,OAAO,CAACH,GAAD,CAAjB,EAAwBA,GAAxB,CAAjB;EACH,CAFD,EAN6B,CAS7B;EACA;;EACA,OAAOqL,MAAP,EAAe;IACXA,MAAM,GAAG,KAAT;;IACA,KAAK,IAAIvI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqI,WAAW,CAACpI,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;MAAA,2BAChCmC,EADgC;QAErC,IAAMqG,SAAS,GAAGH,WAAW,CAACrI,CAAD,CAAX,CAAepB,MAAf,CAAsB,UAAUkF,CAAV,EAAa;UACjD,OAAOuE,WAAW,CAAClG,EAAD,CAAX,CAAgB6D,OAAhB,CAAwBlC,CAAxB,MAA+B,CAAC,CAAvC;QACH,CAFiB,CAAlB;;QAGA,IAAI0E,SAAS,CAACvI,MAAd,EAAsB;UAClBoI,WAAW,CAACrI,CAAD,CAAX,GAAiBqI,WAAW,CAACrI,CAAD,CAAX,CAAerB,MAAf,CAAsB0J,WAAW,CAAClG,EAAD,CAAjC,CAAjB;UACAkG,WAAW,CAACI,MAAZ,CAAmBtG,EAAnB,EAAuB,CAAvB;UACAoG,MAAM,GAAG,IAAT;UACA;QACH;MAVoC;;MACzC,KAAK,IAAIpG,EAAE,GAAGnC,CAAC,GAAG,CAAlB,EAAqBmC,EAAE,GAAGkG,WAAW,CAACpI,MAAtC,EAA8CkC,EAAE,EAAhD,EAAoD;QAAA,iBAA3CA,EAA2C;;QAAA,sBAQ5C;MAEP;IACJ;EACJ,CA1B4B,CA2B7B;EACA;;;EACAkG,WAAW,CAACvJ,OAAZ,CAAoB,UAAU4J,UAAV,EAAsB;IACtCA,UAAU,GAAGA,UAAU,CAAC9J,MAAX,CAAkB,UAAUkF,CAAV,EAAa9D,CAAb,EAAgB2I,IAAhB,EAAsB;MACjD,OAAOA,IAAI,CAAC3C,OAAL,CAAalC,CAAb,MAAoB9D,CAA3B;IACH,CAFY,CAAb;IAGA,IAAM4I,SAAS,GAAGF,UAAU,CAACvJ,GAAX,EAAlB;;IACA,IAAIyJ,SAAS,KAAKzM,SAAd,IAA2B,OAAOyM,SAAP,KAAqB,QAApD,EAA8D;MAC1DN,QAAQ,CAACM,SAAD,CAAR,GAAsBF,UAAtB;IACH;EACJ,CARD;EASA,OAAOJ,QAAP;AACH,C,CACD;AACA;AACA;;;AACA,SAASvE,SAAT,CAAmB8E,IAAnB,EAAyB;EACrB,OAAOA,IAAI,KAAK1M,SAAT,GAAqB0M,IAAI,GAAG,CAA5B,GAAgC,CAAvC;AACH,C,CACD;AACA;;;AACA,SAASzC,WAAT,CAAqBlJ,GAArB,EAA0B;EACtB,IAAIA,GAAG,KAAK,WAAZ,EACI,OAAO,aAAP;EACJ,OAAOA,GAAP;AACH;;AACD,SAAS2G,WAAT,CAAqBb,GAArB,EAA0B;EACtB,OAAQ,OAAOA,GAAP,KAAe,QAAf,KACHA,GAAG,CAAC,CAAD,CAAH,KAAW,GAAX,IAAkBA,GAAG,CAAC,CAAD,CAAH,KAAW,GAD1B,KAEJA,GAAG,CAACA,GAAG,CAAC/C,MAAJ,GAAa,CAAd,CAAH,KAAwB+C,GAAG,CAAC,CAAD,CAFxB,GAGDA,GAAG,CAACyC,SAAJ,CAAc,CAAd,EAAiBzC,GAAG,CAAC/C,MAAJ,GAAa,CAA9B,CAHC,GAID+C,GAJN;AAKH"},"metadata":{},"sourceType":"module"}