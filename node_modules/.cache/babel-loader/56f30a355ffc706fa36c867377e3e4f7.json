{"ast":null,"code":"'use strict';\n\nimport _toConsumableArray from \"/Users/mu.../Documents/Boolean/React/WeatherApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/mu.../Documents/Boolean/React/WeatherApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mu.../Documents/Boolean/React/WeatherApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar align = {\n  right: alignRight,\n  center: alignCenter\n};\nvar top = 0;\nvar right = 1;\nvar bottom = 2;\nvar left = 3;\nexport var UI = /*#__PURE__*/function () {\n  function UI(opts) {\n    _classCallCheck(this, UI);\n\n    var _a;\n\n    this.width = opts.width;\n    this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n    this.rows = [];\n  }\n\n  _createClass(UI, [{\n    key: \"span\",\n    value: function span() {\n      var cols = this.div.apply(this, arguments);\n      cols.span = true;\n    }\n  }, {\n    key: \"resetOutput\",\n    value: function resetOutput() {\n      this.rows = [];\n    }\n  }, {\n    key: \"div\",\n    value: function div() {\n      var _this = this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (args.length === 0) {\n        this.div('');\n      }\n\n      if (this.wrap && this.shouldApplyLayoutDSL.apply(this, args) && typeof args[0] === 'string') {\n        return this.applyLayoutDSL(args[0]);\n      }\n\n      var cols = args.map(function (arg) {\n        if (typeof arg === 'string') {\n          return _this.colFromString(arg);\n        }\n\n        return arg;\n      });\n      this.rows.push(cols);\n      return cols;\n    }\n  }, {\n    key: \"shouldApplyLayoutDSL\",\n    value: function shouldApplyLayoutDSL() {\n      return arguments.length === 1 && typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string' && /[\\t\\n]/.test(arguments.length <= 0 ? undefined : arguments[0]);\n    }\n  }, {\n    key: \"applyLayoutDSL\",\n    value: function applyLayoutDSL(str) {\n      var _this2 = this;\n\n      var rows = str.split('\\n').map(function (row) {\n        return row.split('\\t');\n      });\n      var leftColumnWidth = 0; // simple heuristic for layout, make sure the\n      // second column lines up along the left-hand.\n      // don't allow the first column to take up more\n      // than 50% of the screen.\n\n      rows.forEach(function (columns) {\n        if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n          leftColumnWidth = Math.min(Math.floor(_this2.width * 0.5), mixin.stringWidth(columns[0]));\n        }\n      }); // generate a table:\n      //  replacing ' ' with padding calculations.\n      //  using the algorithmically generated width.\n\n      rows.forEach(function (columns) {\n        _this2.div.apply(_this2, _toConsumableArray(columns.map(function (r, i) {\n          return {\n            text: r.trim(),\n            padding: _this2.measurePadding(r),\n            width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined\n          };\n        })));\n      });\n      return this.rows[this.rows.length - 1];\n    }\n  }, {\n    key: \"colFromString\",\n    value: function colFromString(text) {\n      return {\n        text: text,\n        padding: this.measurePadding(text)\n      };\n    }\n  }, {\n    key: \"measurePadding\",\n    value: function measurePadding(str) {\n      // measure padding without ansi escape codes\n      var noAnsi = mixin.stripAnsi(str);\n      return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var _this3 = this;\n\n      var lines = [];\n      this.rows.forEach(function (row) {\n        _this3.rowToString(row, lines);\n      }); // don't display any lines with the\n      // hidden flag set.\n\n      return lines.filter(function (line) {\n        return !line.hidden;\n      }).map(function (line) {\n        return line.text;\n      }).join('\\n');\n    }\n  }, {\n    key: \"rowToString\",\n    value: function rowToString(row, lines) {\n      var _this4 = this;\n\n      this.rasterize(row).forEach(function (rrow, r) {\n        var str = '';\n        rrow.forEach(function (col, c) {\n          var width = row[c].width; // the width with padding.\n\n          var wrapWidth = _this4.negatePadding(row[c]); // the width without padding.\n\n\n          var ts = col; // temporary string used during alignment/padding.\n\n          if (wrapWidth > mixin.stringWidth(col)) {\n            ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));\n          } // align the string within its column.\n\n\n          if (row[c].align && row[c].align !== 'left' && _this4.wrap) {\n            var fn = align[row[c].align];\n            ts = fn(ts, wrapWidth);\n\n            if (mixin.stringWidth(ts) < wrapWidth) {\n              ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);\n            }\n          } // apply border and padding to string.\n\n\n          var padding = row[c].padding || [0, 0, 0, 0];\n\n          if (padding[left]) {\n            str += ' '.repeat(padding[left]);\n          }\n\n          str += addBorder(row[c], ts, '| ');\n          str += ts;\n          str += addBorder(row[c], ts, ' |');\n\n          if (padding[right]) {\n            str += ' '.repeat(padding[right]);\n          } // if prior row is span, try to render the\n          // current row on the prior line.\n\n\n          if (r === 0 && lines.length > 0) {\n            str = _this4.renderInline(str, lines[lines.length - 1]);\n          }\n        }); // remove trailing whitespace.\n\n        lines.push({\n          text: str.replace(/ +$/, ''),\n          span: row.span\n        });\n      });\n      return lines;\n    } // if the full 'source' can render in\n    // the target line, do so.\n\n  }, {\n    key: \"renderInline\",\n    value: function renderInline(source, previousLine) {\n      var match = source.match(/^ */);\n      var leadingWhitespace = match ? match[0].length : 0;\n      var target = previousLine.text;\n      var targetTextWidth = mixin.stringWidth(target.trimRight());\n\n      if (!previousLine.span) {\n        return source;\n      } // if we're not applying wrapping logic,\n      // just always append to the span.\n\n\n      if (!this.wrap) {\n        previousLine.hidden = true;\n        return target + source;\n      }\n\n      if (leadingWhitespace < targetTextWidth) {\n        return source;\n      }\n\n      previousLine.hidden = true;\n      return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n    }\n  }, {\n    key: \"rasterize\",\n    value: function rasterize(row) {\n      var _this5 = this;\n\n      var rrows = [];\n      var widths = this.columnWidths(row);\n      var wrapped; // word wrap all columns, and create\n      // a data-structure that is easy to rasterize.\n\n      row.forEach(function (col, c) {\n        // leave room for left and right padding.\n        col.width = widths[c];\n\n        if (_this5.wrap) {\n          wrapped = mixin.wrap(col.text, _this5.negatePadding(col), {\n            hard: true\n          }).split('\\n');\n        } else {\n          wrapped = col.text.split('\\n');\n        }\n\n        if (col.border) {\n          wrapped.unshift('.' + '-'.repeat(_this5.negatePadding(col) + 2) + '.');\n          wrapped.push(\"'\" + '-'.repeat(_this5.negatePadding(col) + 2) + \"'\");\n        } // add top and bottom padding.\n\n\n        if (col.padding) {\n          var _wrapped, _wrapped2;\n\n          (_wrapped = wrapped).unshift.apply(_wrapped, _toConsumableArray(new Array(col.padding[top] || 0).fill('')));\n\n          (_wrapped2 = wrapped).push.apply(_wrapped2, _toConsumableArray(new Array(col.padding[bottom] || 0).fill('')));\n        }\n\n        wrapped.forEach(function (str, r) {\n          if (!rrows[r]) {\n            rrows.push([]);\n          }\n\n          var rrow = rrows[r];\n\n          for (var i = 0; i < c; i++) {\n            if (rrow[i] === undefined) {\n              rrow.push('');\n            }\n          }\n\n          rrow.push(str);\n        });\n      });\n      return rrows;\n    }\n  }, {\n    key: \"negatePadding\",\n    value: function negatePadding(col) {\n      var wrapWidth = col.width || 0;\n\n      if (col.padding) {\n        wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n      }\n\n      if (col.border) {\n        wrapWidth -= 4;\n      }\n\n      return wrapWidth;\n    }\n  }, {\n    key: \"columnWidths\",\n    value: function columnWidths(row) {\n      if (!this.wrap) {\n        return row.map(function (col) {\n          return col.width || mixin.stringWidth(col.text);\n        });\n      }\n\n      var unset = row.length;\n      var remainingWidth = this.width; // column widths can be set in config.\n\n      var widths = row.map(function (col) {\n        if (col.width) {\n          unset--;\n          remainingWidth -= col.width;\n          return col.width;\n        }\n\n        return undefined;\n      }); // any unset widths should be calculated.\n\n      var unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n      return widths.map(function (w, i) {\n        if (w === undefined) {\n          return Math.max(unsetWidth, _minWidth(row[i]));\n        }\n\n        return w;\n      });\n    }\n  }]);\n\n  return UI;\n}();\n\nfunction addBorder(col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) {\n      return '';\n    }\n\n    if (ts.trim().length !== 0) {\n      return style;\n    }\n\n    return '  ';\n  }\n\n  return '';\n} // calculates the minimum width of\n// a column, based on padding preferences.\n\n\nfunction _minWidth(col) {\n  var padding = col.padding || [];\n  var minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n\n  if (col.border) {\n    return minWidth + 4;\n  }\n\n  return minWidth;\n}\n\nfunction getWindowWidth() {\n  /* istanbul ignore next: depends on terminal */\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n    return process.stdout.columns;\n  }\n\n  return 80;\n}\n\nfunction alignRight(str, width) {\n  str = str.trim();\n  var strWidth = mixin.stringWidth(str);\n\n  if (strWidth < width) {\n    return ' '.repeat(width - strWidth) + str;\n  }\n\n  return str;\n}\n\nfunction alignCenter(str, width) {\n  str = str.trim();\n  var strWidth = mixin.stringWidth(str);\n  /* istanbul ignore next */\n\n  if (strWidth >= width) {\n    return str;\n  }\n\n  return ' '.repeat(width - strWidth >> 1) + str;\n}\n\nvar mixin;\nexport function cliui(opts, _mixin) {\n  mixin = _mixin;\n  return new UI({\n    width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n    wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n  });\n}","map":{"version":3,"names":["align","right","alignRight","center","alignCenter","top","bottom","left","UI","opts","_a","width","wrap","rows","cols","div","span","args","length","shouldApplyLayoutDSL","applyLayoutDSL","map","arg","colFromString","push","test","str","split","row","leftColumnWidth","forEach","columns","mixin","stringWidth","Math","min","floor","r","i","text","trim","padding","measurePadding","undefined","noAnsi","stripAnsi","match","lines","rowToString","filter","line","hidden","join","rasterize","rrow","col","c","wrapWidth","negatePadding","ts","repeat","fn","addBorder","renderInline","replace","source","previousLine","leadingWhitespace","target","targetTextWidth","trimRight","trimLeft","rrows","widths","columnWidths","wrapped","hard","border","unshift","Array","fill","unset","remainingWidth","unsetWidth","w","max","_minWidth","style","minWidth","getWindowWidth","process","stdout","strWidth","cliui","_mixin"],"sources":["/Users/mu.../Documents/Boolean/React/WeatherApp/node_modules/cliui/build/lib/index.js"],"sourcesContent":["'use strict';\nconst align = {\n    right: alignRight,\n    center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\nexport class UI {\n    constructor(opts) {\n        var _a;\n        this.width = opts.width;\n        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n        this.rows = [];\n    }\n    span(...args) {\n        const cols = this.div(...args);\n        cols.span = true;\n    }\n    resetOutput() {\n        this.rows = [];\n    }\n    div(...args) {\n        if (args.length === 0) {\n            this.div('');\n        }\n        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {\n            return this.applyLayoutDSL(args[0]);\n        }\n        const cols = args.map(arg => {\n            if (typeof arg === 'string') {\n                return this.colFromString(arg);\n            }\n            return arg;\n        });\n        this.rows.push(cols);\n        return cols;\n    }\n    shouldApplyLayoutDSL(...args) {\n        return args.length === 1 && typeof args[0] === 'string' &&\n            /[\\t\\n]/.test(args[0]);\n    }\n    applyLayoutDSL(str) {\n        const rows = str.split('\\n').map(row => row.split('\\t'));\n        let leftColumnWidth = 0;\n        // simple heuristic for layout, make sure the\n        // second column lines up along the left-hand.\n        // don't allow the first column to take up more\n        // than 50% of the screen.\n        rows.forEach(columns => {\n            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));\n            }\n        });\n        // generate a table:\n        //  replacing ' ' with padding calculations.\n        //  using the algorithmically generated width.\n        rows.forEach(columns => {\n            this.div(...columns.map((r, i) => {\n                return {\n                    text: r.trim(),\n                    padding: this.measurePadding(r),\n                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined\n                };\n            }));\n        });\n        return this.rows[this.rows.length - 1];\n    }\n    colFromString(text) {\n        return {\n            text,\n            padding: this.measurePadding(text)\n        };\n    }\n    measurePadding(str) {\n        // measure padding without ansi escape codes\n        const noAnsi = mixin.stripAnsi(str);\n        return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n    }\n    toString() {\n        const lines = [];\n        this.rows.forEach(row => {\n            this.rowToString(row, lines);\n        });\n        // don't display any lines with the\n        // hidden flag set.\n        return lines\n            .filter(line => !line.hidden)\n            .map(line => line.text)\n            .join('\\n');\n    }\n    rowToString(row, lines) {\n        this.rasterize(row).forEach((rrow, r) => {\n            let str = '';\n            rrow.forEach((col, c) => {\n                const { width } = row[c]; // the width with padding.\n                const wrapWidth = this.negatePadding(row[c]); // the width without padding.\n                let ts = col; // temporary string used during alignment/padding.\n                if (wrapWidth > mixin.stringWidth(col)) {\n                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));\n                }\n                // align the string within its column.\n                if (row[c].align && row[c].align !== 'left' && this.wrap) {\n                    const fn = align[row[c].align];\n                    ts = fn(ts, wrapWidth);\n                    if (mixin.stringWidth(ts) < wrapWidth) {\n                        ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);\n                    }\n                }\n                // apply border and padding to string.\n                const padding = row[c].padding || [0, 0, 0, 0];\n                if (padding[left]) {\n                    str += ' '.repeat(padding[left]);\n                }\n                str += addBorder(row[c], ts, '| ');\n                str += ts;\n                str += addBorder(row[c], ts, ' |');\n                if (padding[right]) {\n                    str += ' '.repeat(padding[right]);\n                }\n                // if prior row is span, try to render the\n                // current row on the prior line.\n                if (r === 0 && lines.length > 0) {\n                    str = this.renderInline(str, lines[lines.length - 1]);\n                }\n            });\n            // remove trailing whitespace.\n            lines.push({\n                text: str.replace(/ +$/, ''),\n                span: row.span\n            });\n        });\n        return lines;\n    }\n    // if the full 'source' can render in\n    // the target line, do so.\n    renderInline(source, previousLine) {\n        const match = source.match(/^ */);\n        const leadingWhitespace = match ? match[0].length : 0;\n        const target = previousLine.text;\n        const targetTextWidth = mixin.stringWidth(target.trimRight());\n        if (!previousLine.span) {\n            return source;\n        }\n        // if we're not applying wrapping logic,\n        // just always append to the span.\n        if (!this.wrap) {\n            previousLine.hidden = true;\n            return target + source;\n        }\n        if (leadingWhitespace < targetTextWidth) {\n            return source;\n        }\n        previousLine.hidden = true;\n        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n    }\n    rasterize(row) {\n        const rrows = [];\n        const widths = this.columnWidths(row);\n        let wrapped;\n        // word wrap all columns, and create\n        // a data-structure that is easy to rasterize.\n        row.forEach((col, c) => {\n            // leave room for left and right padding.\n            col.width = widths[c];\n            if (this.wrap) {\n                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\\n');\n            }\n            else {\n                wrapped = col.text.split('\\n');\n            }\n            if (col.border) {\n                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');\n                wrapped.push(\"'\" + '-'.repeat(this.negatePadding(col) + 2) + \"'\");\n            }\n            // add top and bottom padding.\n            if (col.padding) {\n                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n            }\n            wrapped.forEach((str, r) => {\n                if (!rrows[r]) {\n                    rrows.push([]);\n                }\n                const rrow = rrows[r];\n                for (let i = 0; i < c; i++) {\n                    if (rrow[i] === undefined) {\n                        rrow.push('');\n                    }\n                }\n                rrow.push(str);\n            });\n        });\n        return rrows;\n    }\n    negatePadding(col) {\n        let wrapWidth = col.width || 0;\n        if (col.padding) {\n            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n        }\n        if (col.border) {\n            wrapWidth -= 4;\n        }\n        return wrapWidth;\n    }\n    columnWidths(row) {\n        if (!this.wrap) {\n            return row.map(col => {\n                return col.width || mixin.stringWidth(col.text);\n            });\n        }\n        let unset = row.length;\n        let remainingWidth = this.width;\n        // column widths can be set in config.\n        const widths = row.map(col => {\n            if (col.width) {\n                unset--;\n                remainingWidth -= col.width;\n                return col.width;\n            }\n            return undefined;\n        });\n        // any unset widths should be calculated.\n        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n        return widths.map((w, i) => {\n            if (w === undefined) {\n                return Math.max(unsetWidth, _minWidth(row[i]));\n            }\n            return w;\n        });\n    }\n}\nfunction addBorder(col, ts, style) {\n    if (col.border) {\n        if (/[.']-+[.']/.test(ts)) {\n            return '';\n        }\n        if (ts.trim().length !== 0) {\n            return style;\n        }\n        return '  ';\n    }\n    return '';\n}\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth(col) {\n    const padding = col.padding || [];\n    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n    if (col.border) {\n        return minWidth + 4;\n    }\n    return minWidth;\n}\nfunction getWindowWidth() {\n    /* istanbul ignore next: depends on terminal */\n    if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n        return process.stdout.columns;\n    }\n    return 80;\n}\nfunction alignRight(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    if (strWidth < width) {\n        return ' '.repeat(width - strWidth) + str;\n    }\n    return str;\n}\nfunction alignCenter(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    /* istanbul ignore next */\n    if (strWidth >= width) {\n        return str;\n    }\n    return ' '.repeat((width - strWidth) >> 1) + str;\n}\nlet mixin;\nexport function cliui(opts, _mixin) {\n    mixin = _mixin;\n    return new UI({\n        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}